---
title: "Overview of normalised expression data"
bibliography:
  bibtex.bib
---

```{r checkPkgs, child="_checkLibraries.Rmd", include=FALSE}
```

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scater)
library(scran)
library(ggplot2)
library(SummarizedExperiment)
library(DT)
library(dplyr)
library(RColorBrewer)
library(ComplexHeatmap)
library(MKmisc)
library(org.Hs.eg.db)
library(goseq)
sce.norm <- readRDS("rds/sce.norm.rds")
```

# Highly variable genes (HVGs)

We identify HVGs to focus on the genes that are driving heterogeneity across
the population of cells.
This requires estimation of the variance in expression for each gene, followed
by decomposition of the variance into biological and technical components.
HVGs are then identified as those genes with the highest biological components.
This avoids prioritizing genes that are highly variable due to technical
factors such as sampling noise during RNA capture and library preparation.

## Identifying variable genes {#identifyHVGs}

### Using ERCC spike-in features

Ideally, the technical component would be estimated by fitting a mean-variance
trend to the ERCC spike-in feature using the
[scran](http://bioconductor.org/packages/scran) `trendVar` function.
Recall that the same set of spike-ins was added in the same quantity to each
cell.
This means that the spike-in transcripts should exhibit no biological
variability, *i.e.*, any variance in their counts should be technical
in origin.
Given the mean abundance of a gene, the fitted value of the trend can be used
as an estimate of the technical component for that gene.
The biological component of the variance can then be calculated by subtracting
the technical component from the total variance of each gene with the
[scran](http://bioconductor.org/packages/scran) `decomposeVar` function.

Let us fit a trend to the variance of spike-in features while accounting
for the minor effect of technical factors described
[earlier](06_examineNormalised.html#explanatoryVariables).
We do not block on the key experimental factors `Time`, `Infection`, and
`Status`, as doing so may regress out biological effects of interest.

```{r model.matrix_technical}
dm <- model.matrix(~Plate+Lane, data = pData(sce.norm))
colnames(dm)
```

Having defined the design matrix, we fit the mean-dependent trend to the
gene-specific variances in the data set:

```{r trendVar_ercc}
var.fit.ercc <- trendVar(
  sce.norm, assay = "norm_exprs", trend = "loess", design = dm,
  span = 0.4
)
names(var.fit.ercc)
```

We may then decompose the gene-specific variance into biological and technical
components using the ERCC spike-in trend as an estimate of technical variance:

```{r decomposeVar_ercc}
var.out.ercc <- decomposeVar(sce.norm, var.fit.ercc, assay = "norm_exprs")
names(var.out.ercc)
```

Finally, we may plot the fitted trend, while highlighting ERCC spike-in
features used to obtain it:

```{r plot_var.out.ercc}
plot(
  var.out.ercc$mean, var.out.ercc$total, pch = 16, cex = 0.6,
  xlab = "Mean log-expression", ylab = "Variance of log-expression"
)
points(var.fit.ercc$mean, var.fit.ercc$var, col="red", pch=16)
o <- order(var.out.ercc$mean)
lines(var.out.ercc$mean[o], var.out.ercc$tech[o], col="red", lwd=2)
```

While the above figure suggests that the trend fits accurately spike-in
features at extreme values the detection range, it also indicate substantial
scatter around the trend for feature at intermediate levels of detection,
and likely understimates technical variance in both ERCC spike-in and
endogenous features at moderately high levels of detection
(*i.e.*, mean log-expression in the range \approx 5-10).

### Using endogenous features

Considering the technical variance in ERCC spike-in detection levels observed
in the previous section, an alternate method of estimating technical variation
across the dynamic range of expression uses endogenous features expression
levels under the assumption that most endogenous features exhibit mostly
technical variation, in contrast to little biological variation.

Similarly to the use of ERCC spike-in features, let us use the
[scran](http://bioconductor.org/packages/scran) `trendVar` method
to estimate technical variation under the assumption stated above,
accouting for the same technical factors of the experimental design:

```{r trendVar_endo}
var.fit.endo <- trendVar(
  sce.norm, assay = "norm_exprs", trend = "loess", design = dm,
  use.spikes = FALSE, span = 0.1
)
names(var.fit.endo)
```

Similarly, the estimated variance is decomposed into its technical and
biological components (using only the endogenous features processed above):

```{r decomposeVar_endo}
var.out.endo <- decomposeVar(sce.norm, var.fit.endo)
names(var.out.endo)
```

We assess the suitability of the trend fitted to the endogenous variances by examining whether it is consistent with the spike-in variances.
The trend passes through or close to most of the spike-in variances, indicating
that our assumption (that most genes have low levels of biological variability)
is valid.
This strategy exploits the large number of endogenous genes to obtain a stable
trend, with the ERCC spike-in feature used as diagnostic features rather than
in the trend fitting itself.
However, if our assumption did not hold, we would instead use the trend fitted to the ERCC spike-in variances with the default `use.spikes=TRUE`. This would 
sacrifice stability to reduce systematic errors in the estimate of
the biological component for each gene [@67].

```{r plot_var.out.endo}
plot(
  var.out.endo$mean, var.out.endo$total, pch=16, cex=0.6,
  xlab="Mean log-expression", ylab="Variance of log-expression"
)
o <- order(var.out.endo$mean)
lines(var.out.endo$mean[o], var.out.endo$tech[o], col="dodgerblue", lwd=2)
spike.fit <- trendVar(sce.norm, use.spikes=TRUE) # To compute spike-in variances.
points(spike.fit$mean, spike.fit$var, col="red", pch=16)
```

\bioccomment{
The help page for `trendVar` suggests fiddling with arguments for smoothing
such as `span`, `degree`, or `family` or using `semiloess` to produce the
trend. I haved tried the `gaussian` family which barely affects the smoothing
of the ERCC spike-in features, and the `semiloess` trend which does not
converge for ERCC spike-in features.
}

## Model selection

The two methods (*i.e.*, ERCC spike-in and endogenous features) yield markedly
distinct trends.

In particular, the limited count of spike-in features robustly detected
across cells
(*i.e.*, `r sum(grepl("^ERCC-",rownames(sce.norm)))`
ERCC spike-in features were retained in the `sce.norm` object),
scarcer at moderate levels of expression,
may explain to some extent the substantial scatter around the trend at moderate
levels of expression
(*i.e.*, mean log-expression in the range \approx 2.5-7.5).
Nevertheless, this trend matches closely observations at low detection levels
dense in ERCC spike-in features, and high detection levels that show limited
variability.

In contrast, the use of endogenous features---under the assumption that most
genes exhibit technical variation and little biological variation---yields a
trend that may understimate technical variation at low levels of detection and
overestimate technical variation at high levels of detection, considering
ERCC spike-in for reference. However, at moderate detection levels,
the overall trend provides a more representative average estimate of variance
matching both ERCC spike-in and endogenous features (always under the
assumption that most spike-in and endogenous features only show technical
variation).

Let us adopt a conservative approach and use the latter trend (*i.e.*,
estimated from the endogenous features) as it is consistent with the spike-in
variances, and as such supporting the assumption that most genes have low
levels of biological variability is valid in this data set.

## Ranked HVGs {#HVGs}

HVGs are defined as genes with biological components that are significantly
greater than zero at a false discovery rate (FDR) of 5%.
These genes are interesting as they are most likely to drive differences in the
expression profiles between cells that belong to different experimental groups,
while more generally explaining a substantial proportion of the
transcriptional variance across all cells in the data set.

In addition to the definition above, let us define as HVGs endogenous features
with an estimated biological component of variance greater than or equal to
`0.5`
For transformed expression values on the log~2~ scale, this means that the
average difference in true expression between any two cells will be at least
`2`-fold. This reasoning assumes that the true log-expression
values are Normally distributed with variance of 0.5 [@67].

```{r hvg.out}
hvg.out <- var.out.endo[which(
  var.out.endo$FDR <= 0.05 & var.out.endo$bio >= 0.5
  ),]
hvg.out <- hvg.out[order(hvg.out$bio, decreasing=TRUE),]
nrow(hvg.out)
```

Let us annotate features with their associated gene name:

```{r annotated_hvg.out}
hvg.out <- cbind(
  gene_name = fData(sce.norm)[rownames(hvg.out),]$gene_name,
  hvg.out
)
```

We may then examine the HVGs in a table initially ordered by decreasing
biological variance. For convenience, let us first create a copy of the table
in which the numeric values are trimmed to two significant decimal places:

```{r}
hvg.trim <- hvg.out
for (cname in c("mean","total","bio","tech","p.value","FDR")){
  hvg.trim[,cname] <- round(hvg.trim[,cname], 2)
}
```

```{r pandoc_topBioVariance, results='asis'}
DT::datatable(
  hvg.trim,
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## Expression levels {.tabset}

Let us examine the distribution of expression values for the top HVGs across
cells to ensure that the variance estimate is not being dominated by a small
count of extreme outliers.

We may highlight the relationship between those HVGs and experimental factors
such as `Time`, `Infection`, and `Status`.

```{r top.hvg}
top.hvg <- rownames(hvg.out)[1:10]
```

### Time

```{r top.hvg_Time}
plotExpressionSCESet(
  sce.norm, top.hvg, exprs_values = "norm_exprs", colour_by = "Time"
) + scale_x_discrete(labels = fData(sce.norm[top.hvg,])$gene_name) +
  theme(legend.position = "bottom", legend.box = "vertical")
```

The figure above generally indicates a progressive *up*-regulation of gene
expression over time.

### Infection

```{r top.hvg_Infection}
plotExpressionSCESet(
  sce.norm, top.hvg, exprs_values = "norm_exprs", colour_by = "Infection"
) + scale_x_discrete(labels = fData(sce.norm[top.hvg,])$gene_name) +
  theme(legend.position = "bottom", legend.box = "vertical")
```

The figure above further links the high variance of those genes to
the differences between bacteria-stimulated and mock-infected cells.

### Status

```{r top.hvg_Status}
plotExpressionSCESet(
  sce.norm, top.hvg, exprs_values = "norm_exprs", colour_by = "Status"
) + scale_x_discrete(labels = fData(sce.norm[top.hvg,])$gene_name) +
  theme(legend.position = "bottom", legend.box = "vertical")
```

The figure above reinforces clear-cut differences between cells
stimulated by bacterial infection or exposure and `uninfected` cells.

# Expression heatmap {.tabset}

We may then visualise normalised and scaled expression values in
a heat map manually organised by phenotype, while allowing genes with similar
expression profiles to cluster.

Let us first subset the normalised data set to retain only endogenous features:

```{r excludeERCC}
sce.endo <- sce.norm[!fData(sce.norm)$is_feature_control_ERCC,]
dim(sce.endo)
```

In addition, let us also reorder samples by `Time`, `Status`, and `Infection`,
to facilitate interpretation of the expression data:

```{r orderSamples}
sce.endo <- sce.endo[,with(pData(sce.endo), order(Time, Status, Infection))]
dim(sce.endo)
```

We may now examine the expression data of the ``r nrow(sce.endo)``
endogenous HVGs identified [above](#identifyHVGs):

```{r topHVG.norm}
hvg.endo <- norm_exprs(sce.endo)[rownames(hvg.out),]
dim(hvg.endo)
```

Let us prepare colours to indicate phenotype levels:

```{r palette9}
col9 <- brewer.pal(10, "Set3")[c(1:8, 10)]
```

In preparation for the heat map, let us define an annotation panel
that indicates key phenotype levels for each cell:

```{r h_column}
h_column <- HeatmapAnnotation(
  df = pData(sce.endo)[,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
```

Let us first cluster HVGs according to their expression profile across *all*
single cells:

```{r hvg.endo.clust}
hvg.endo.d <- dist(hvg.endo)
hvg.endo.clust <- hclust(hvg.endo.d)
rm(hvg.endo.d)
```

We may immediately produce a heat map that uses the above gene clustering,
while grouping samples arbitrarily according to their respective
`Time`, `Status`, and `Infection` phenotype:

```{r heatmap_supervised}
ht_supervised <- Heatmap(
  hvg.endo,
  name = "norm_exprs", column_title = "Normalised expression",
  top_annotation = h_column,
  row_order = hvg.endo.clust$order,
  cluster_rows = hvg.endo.clust, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

Now, let us cluster single cells according to their expression profile,
*within each of the experimental groups* (*i.e.*, `Time:Infection:Status`):

```{r sample.order}
sample.order <- c()
expGroups <- unique(pData(sce.endo)[,c("Time","Infection","Status")])
expGroups <- arrange(expGroups, Time, Status, Infection)
for (groupIndex in seq_len(nrow(expGroups))){
  time <- expGroups$Time[groupIndex]
  infection <- expGroups$Infection[groupIndex]
  status <- expGroups$Status[groupIndex]
  sample.index <- with(pData(sce.endo), which(
    Time == time & Infection == infection & Status == status
  ))
  hvg.sample.d <- dist(t(hvg.endo[,sample.index]))
  local.order <- sample.index[hclust(hvg.sample.d)$order]
  sample.order <- c(sample.order, local.order)
  rm(sample.index, local.order, time, infection, status)
}
rm(expGroups, groupIndex)
```

We may then produce a heat map that uses the above semi-supervised sample
clustering in combination with the earlier gene clustering, to reveal potential
sub-structure within the otherwise homogeneous experimental groups:

```{r heatmap_semiSupervised}
ht_semisupervised <- Heatmap(
  hvg.endo,
  name = "norm_exprs", column_title = "Normalised expression",
  top_annotation = h_column,
  row_order = hvg.endo.clust$order, column_order = sample.order,
  cluster_rows = hvg.endo.clust, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

Let us use the [goseq](http://bioconductor.org/packages/goseq) package to
identify the most enriched gene ontologies among the HVGs:

```{r GO.out}
hvgs <- as.integer(rownames(sce.endo) %in% rownames(hvg.endo))
names(hvgs) <- rownames(sce.endo)
table(hvgs)
geneLengths <- read.delim(
  "counts/WTCHG_305264_201201", row.names = 1)[,1, drop = FALSE]
pwf <- nullp(hvgs, bias.data = geneLengths[names(hvgs),], plot.fit = FALSE)
GO.out <- goseq(pwf, "hg38", "ensGene")
GO.out$ontology <- as.factor(GO.out$ontology)
DT::datatable(
  subset(GO.out, over_represented_pvalue < 0.001),
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

Let us retrieve the identifier of genes associated with the most enriched
category ``r GO.out$term[1]`` with identifier ``r GO.out$category[1]``:

```{r genes.top, message=FALSE}
genes.topCategory <- unique(AnnotationDbi::select(
  org.Hs.eg.db, GO.out$category[1], "ENSEMBL", "GOALL")$ENSEMBL
)
table(rownames(hvg.endo) %in% genes.topCategory)
```

Let us also annotated genes relating to the
*type I interferon signaling pathway* in the same way:

```{r genes.ifn, message=FALSE}
genes.ifn <- unique(AnnotationDbi::select(
  org.Hs.eg.db, "GO:0060337", "ENSEMBL", "GOALL")$ENSEMBL
)
table(rownames(hvg.endo) %in% genes.ifn)
```

Let us annotate genes associated with the above GO categories on the heat map:

```{r heatmap_GO_annotations}
top_l <- rownames(hvg.endo) %in% genes.topCategory
h_top <- Heatmap(top_l + 0, name = GO.out$term[1], col = c("0" = "white", "1" = "purple"),
        show_heatmap_legend = FALSE, width = unit(5, "mm"))
ifn_l <- rownames(hvg.endo) %in% genes.ifn
h_ifn <- Heatmap(ifn_l + 0, name = "IFN-I", col = c("0" = "white", "1" = "red"), 
        show_heatmap_legend = FALSE, width = unit(5, "mm"))
```

## Supervised

```{r ht_supervised, fig.height=7}
draw(ht_supervised + h_top + h_ifn)
```

## Semi-supervised

```{r ht_semisupervised, fig.height=7}
draw(ht_semisupervised + h_top + h_ifn)
```

# Pairwise distances between samples

## Euclidian distance

### Estimate distances

Calculate the Euclidian distance between samples using the
normalised expression data calculated in a
[previous section](05_normalisation.html#normalize)
scaled (mean: `0`; standard deviation: `1`) for the
``r nrow(hvg.endo)`` HVGs identified [above](#HVGs):

```{r distEuclidScaled}
hvg.scaled <- t(scale(t(hvg.endo)))
d.e.s <- dist(t(hvg.scaled), diag = TRUE, upper = TRUE)
mat.e.s <- as.matrix(d.e.s)
```

For comparison purposes, let us do the same with normalised (unscaled) values:

```{r distEuclidNorm}
d.e.n <- dist(t(hvg.endo), diag = TRUE, upper = TRUE)
mat.e.n <- as.matrix(d.e.n)
```

We may then cluster samples according to their Euclidian distance for scaled
values, using Ward's criterion to minimize the total variance within each
cluster [@67]:

```{r clustEuclidScaled}
h.e.s <- hclust(d.e.s) #, method = "ward.D2"
ord.e.s <- mat.e.s[h.e.s$order, h.e.s$order]
rm(mat.e.s)
```

Again, do the same for unscaled values:

```{r clustEuclidNorm}
h.e.n <- hclust(d.e.n) #, method = "ward.D2"
ord.e.n <- mat.e.n[h.e.n$order, h.e.n$order]
rm(mat.e.n)
```

### Heat maps {.tabset}

Draw the heat maps using Euclidian distance for normalised or
normalised-scaled data:

```{r heatEuclid}
hs_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.e.s$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
hs <- Heatmap(
  ord.e.s, name = "distance", column_title = "Normalised scaled",
  top_annotation = hs_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
hn_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.e.n$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
hn <- Heatmap(
  ord.e.n, name = "distance", column_title = "Normalised unscaled",
  top_annotation = hn_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

#### Scaled

```{r heatEuclidNorm, fig.height=6}
draw(hs)
```

#### Normalised

```{r heatEuclidScaled, fig.height=6}
draw(hn)
```

## Spearman correlation

### Estimate distances

Estimate distance between cells using Spearman's (rank) correlation.

**Note:**
The rank correlation is insensitive to the scaling process (the order
of samples are preserved by the scaling procedure). Therefore, there is
no need to compare the identical heat maps produced for the two data sets.
}

```{r distSpearman}
c.s <- corDist(t(hvg.endo), "spearman", diag = TRUE, upper = TRUE)
mat.c.s <- as.matrix(c.s)
```

Cluster samples:

```{r clustSpearman}
h.c.s <- hclust(c.s)
ord.c.s <- mat.c.s[h.c.s$order, h.c.s$order]
rm(c.s)
```

The heat map is shown along with those using Pearson correlation further
[below](#correlationHeatMaps).

## Pearson correlation

### Estimate distances

Estimate distance between cells using Pearson's correlation.
Let us compare the effect of scaling the expression data (by gene)
on the correlation between samples.

We start calculating the sample correlation using the unscaled normalised data:

```{r distPearsonNorm}
c.p.n <- corDist(t(hvg.endo), diag = TRUE, upper = TRUE)
mat.c.p.n <- as.matrix(c.p.n)
```

We then do the same with the scaled data:

```{r distPearsonScaled}
c.p.s <- corDist(t(hvg.scaled), diag = TRUE, upper = TRUE)
mat.c.p.s <- as.matrix(c.p.s)
```

Cluster samples using Pearson's correlation for the unscaled data:

```{r clustPearsonNorm}
h.c.p.n <- hclust(c.p.n)
ord.c.p.n <- mat.c.p.n[h.c.p.n$order, h.c.p.n$order]
rm(c.p.n)
```

And the same for the scaled data:

```{r clustPearsonScaled}
h.c.p.s <- hclust(c.p.s)
ord.c.p.s <- mat.c.p.s[h.c.p.s$order, h.c.p.s$order]
rm(c.p.s)
```

### Heat maps {#correlationHeatMaps .tabset}

Let us prepare the heat map using Spearman's $\rho$ correlation:

```{r heatSpearman}
ht_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.c.s$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
ht_s <- Heatmap(
  ord.c.s, name = "distance", column_title = "Spearman distance",
  top_annotation = ht_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

Followed by the heat maps using Pearson's _r_ correlation
(*i.e.*, normalised, and normalised scaled):

```{r heatPearson}
hn_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.c.p.n$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
ht_pn <- Heatmap(
  ord.c.p.n, name = "distance", column_title = "Normalised unscaled",
  top_annotation = hn_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
hs_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.c.p.s$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
ht_ps <- Heatmap(
  ord.c.p.s, name = "distance", column_title = "Normalised scaled",
  top_annotation = hs_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

#### Spearman

```{r ht_s, fig.height=6}
draw(ht_s)
```

#### Pearson (normalised)

```{r heatPearsonNorm, fig.height=6}
draw(ht_pn)
```

#### Pearson (scaled)

```{r heatPearsonScaled, fig.height=6}
draw(ht_ps)
```

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->

```{r saveRDS, include=FALSE}
saveRDS(hvg.out, "rds/hvg.out.rds")
```

# References
