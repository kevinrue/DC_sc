---
title: "Overview of normalised expression data"
bibliography:
  bibtex.bib
---

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scater)
library(scran)
library(ggplot2)
library(gplots)
library(SummarizedExperiment)
library(ComplexHeatmap)
sce.norm <- readRDS("rds/sce.norm.rds")
library(org.Hs.eg.db)
library(EnsDb.Hsapiens.v79)
library(goseq)
library(DT)
library(reshape2)
library(dplyr)
```

# Plotting themes

First of all, let us define theme elements used throughout various figures
in the following sections:

```{r exprsViolinTheme}
exprsViolinTheme <- theme(
    panel.grid.major.x = element_blank(),
    legend.position = "bottom", legend.box = "vertical")
```

# Highly variable genes (HVGs)

We identify HVGs to focus on the genes that are driving heterogeneity across
the population of cells.
This requires estimation of the variance in expression for each gene, followed
by decomposition of the variance into biological and technical components.
HVGs are then identified as those genes with the biological component
most significantly greater than the technical component.
This avoids prioritizing genes that are highly variable due to technical
factors such as sampling noise during RNA capture and library preparation.

## Identifying variable genes {#identifyHVGs}

### Using ERCC spike-in features

Ideally, the technical component would be estimated by fitting a mean-variance
trend to the ERCC spike-in feature using the
[scran](http://bioconductor.org/packages/scran) `trendVar` function.
Recall that the same set of spike-ins was added in the same quantity to each
cell.
This means that the spike-in transcripts should exhibit no biological
variability, *i.e.*, any variance in their counts should be technical
in origin.
Given the mean abundance of a gene, the fitted value of the trend can be used
as an estimate of the technical component for that gene.
The biological component of the variance can then be calculated by subtracting
the technical component from the total variance of each gene with the
[scran](http://bioconductor.org/packages/scran) `decomposeVar` function.

Let us fit a trend to the variance of spike-in features while accounting
for the minor effect of technical factors described
[earlier](06_examineNormalised.html#explanatoryVariables).
We do not block on the key experimental factors `Time`, `Infection`, and
`Status`, as doing so may regress out biological effects of interest.

```{r model.matrix_technical}
dm <- model.matrix(~Plate+Lane, data = pData(sce.norm))
colnames(dm)
```

Having defined the design matrix, we fit the mean-dependent trend to the
gene-specific variances in the data set:

```{r trendVar_ercc}
var.fit.ercc <- trendVar(
  sce.norm, assay = "norm_exprs", trend = "loess", design = dm,
  span = 0.4
)
names(var.fit.ercc)
```

We may then decompose the gene-specific variance into biological and technical
components using the ERCC spike-in trend as an estimate of technical variance:

```{r decomposeVar_ercc}
var.out.ercc <- decomposeVar(sce.norm, var.fit.ercc, assay = "norm_exprs")
names(var.out.ercc)
```

Finally, we may plot the fitted trend, while highlighting ERCC spike-in
features used to obtain it:

```{r plot_var.out.ercc}
plot(
  var.out.ercc$mean, var.out.ercc$total, pch = 16, cex = 0.6,
  xlab = "Mean log-expression", ylab = "Variance of log-expression"
)
points(var.fit.ercc$mean, var.fit.ercc$var, col="red", pch=16)
o <- order(var.out.ercc$mean)
lines(var.out.ercc$mean[o], var.out.ercc$tech[o], col="red", lwd=2)
```

While the above figure suggests that the trend fits accurately spike-in
features at extreme values the detection range, it also indicate substantial
scatter around the trend for feature at intermediate levels of detection,
and likely understimates technical variance in both ERCC spike-in and
endogenous features at moderately high levels of detection
(*i.e.*, mean log-expression in the range \approx 5-10).

### Using endogenous features

Considering the technical variance in ERCC spike-in detection levels observed
in the previous section, an alternate method of estimating technical variation
across the dynamic range of expression uses endogenous features expression
levels under the assumption that most endogenous features exhibit mostly
technical variation, in contrast to little biological variation.

Similarly to the use of ERCC spike-in features, let us use the
[scran](http://bioconductor.org/packages/scran) `trendVar` method
to estimate technical variation under the assumption stated above,
accouting for the same technical factors of the experimental design:

```{r trendVar_endo}
var.fit.endo <- trendVar(
  sce.norm, assay = "norm_exprs", trend = "loess", design = dm,
  use.spikes = FALSE, span = 0.1
)
names(var.fit.endo)
```

Similarly, the estimated variance is decomposed into its technical and
biological components (using only the endogenous features processed above):

```{r decomposeVar_endo}
var.out.endo <- decomposeVar(sce.norm, var.fit.endo)
names(var.out.endo)
```

We assess the suitability of the trend fitted to the endogenous variances by
examining whether it is consistent with the spike-in variances.
The trend passes through or close to most of the spike-in variances, indicating
that our assumption (that most genes have low levels of biological variability)
is valid.
This strategy exploits the large number of endogenous genes to obtain a stable
trend, with the ERCC spike-in feature used as diagnostic features rather than
in the trend fitting itself.
However, if our assumption did not hold, we would instead use the trend fitted
to the ERCC spike-in variances with the default `use.spikes=TRUE`. This would 
sacrifice stability to reduce systematic errors in the estimate of
the biological component for each gene [@67].

```{r plot_var.out.endo}
plot(
  var.out.endo$mean, var.out.endo$total, pch=16, cex=0.6,
  xlab="Mean log-expression", ylab="Variance of log-expression"
)
o <- order(var.out.endo$mean)
lines(var.out.endo$mean[o], var.out.endo$tech[o], col="dodgerblue", lwd=2)
spike.fit <- trendVar(sce.norm, use.spikes=TRUE) # To compute spike-in variances.
points(spike.fit$mean, spike.fit$var, col="red", pch=16)
```

\bioccomment{
The help page for `trendVar` suggests fiddling with arguments for smoothing
such as `span`, `degree`, or `family` or using `semiloess` to produce the
trend. I haved tried the `gaussian` family which barely affects the smoothing
of the ERCC spike-in features, and the `semiloess` trend which does not
converge for ERCC spike-in features.
}

## Model selection

The two methods (*i.e.*, ERCC spike-in and endogenous features) yield markedly
distinct trends.

In particular, the limited count of spike-in features robustly detected
across cells
(*i.e.*, `r sum(grepl("^ERCC-",rownames(sce.norm)))`
ERCC spike-in features were retained in the `sce.norm` object),
scarcer at moderate levels of expression,
may explain to some extent the substantial scatter around the trend at moderate
levels of expression
(*i.e.*, mean log-expression in the range $\approx [2.5 - 7.5]$).
Nevertheless, this trend matches closely observations at low detection levels
dense in ERCC spike-in features, and high detection levels that show limited
variability.

In contrast, the use of endogenous features---under the assumption that most
genes exhibit technical variation and little biological variation---yields a
trend that may understimate technical variation at low levels of detection and
overestimate technical variation at high levels of detection, considering
ERCC spike-in for reference. However, at moderate detection levels,
the overall trend provides a more representative average estimate of variance
matching both ERCC spike-in and endogenous features (always under the
assumption that most spike-in and endogenous features only show technical
variation).

Let us adopt a conservative approach and use the latter trend (*i.e.*,
estimated from the endogenous features) as it is consistent with the spike-in
variances, and as such supporting the assumption that most genes have low
levels of biological variability is valid in this data set.

## Ranked HVGs {#HVGs}

HVGs are defined as genes with biological components that are significantly
greater than zero at a false discovery rate (FDR) of 5%.
These genes are interesting as they are most likely to drive differences in the
expression profiles between cells that belong to different experimental groups,
while more generally explaining a substantial proportion of the
transcriptional variance across all cells in the data set.

In addition to the definition above, let us define as HVGs endogenous features
with an estimated biological component of variance greater than or equal to
0.5.
For transformed expression values on the log~2~ scale, this means that the
average difference in true expression between any two cells will be at least
2-fold. This reasoning assumes that the true log-expression
values are Normally distributed with variance of 0.5 [@67].

```{r hvg.out}
hvg.out <- var.out.endo[which(
  var.out.endo$FDR <= 0.05 & var.out.endo$bio >= 0.5
  ),]
hvg.out <- hvg.out[order(hvg.out$bio, decreasing=TRUE),]
nrow(hvg.out)
```

Let us annotate features with their associated gene name:

```{r annotated_hvg.out}
hvg.out <- cbind(
  gene_name = fData(sce.norm)[rownames(hvg.out),]$gene_name,
  hvg.out
)
```

We may then examine the HVGs in a table initially ordered by decreasing
biological variance. For convenience, let us first create a copy of the table
in which the numeric values are trimmed to two significant decimal places:

```{r hvg.trim}
hvg.trim <- hvg.out
for (cname in c("mean","total","bio","tech","p.value","FDR")){
  hvg.trim[,cname] <- round(hvg.trim[,cname], 2)
}
```

```{r pandoc_topBioVariance, results='asis'}
DT::datatable(
  hvg.trim,
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## Expression levels {.tabset}

Let us examine the distribution of expression values for the top HVGs across
cells to ensure that the variance estimate is not being dominated by a small
count of extreme outliers.

We may highlight the relationship between those HVGs and experimental factors
such as `Time`, `Infection`, and `Status`.

```{r top.hvg}
top.hvg <- rownames(hvg.out)[1:10]
```

### Time

```{r top.hvg_Time}
plotExpressionSCESet(
  sce.norm, top.hvg, exprs_values = "norm_exprs", colour_by = "Time"
  ) + scale_x_discrete(labels = fData(sce.norm[top.hvg,])$gene_name) +
   theme(legend.position = "bottom", legend.box = "vertical")
```

The figure above generally indicates a progressive *up*-regulation of gene
expression over time.

### Infection

```{r top.hvg_Infection}
plotExpressionSCESet(
  sce.norm, top.hvg, exprs_values = "norm_exprs", colour_by = "Infection"
  ) + scale_x_discrete(labels = fData(sce.norm[top.hvg,])$gene_name) +
  exprsViolinTheme
```

The figure above further links the high variance of those genes to
the differences between bacteria-stimulated and mock-infected cells.

### Status

```{r top.hvg_Status}
plotExpressionSCESet(
  sce.norm, top.hvg, exprs_values = "norm_exprs", colour_by = "Status"
  ) + scale_x_discrete(labels = fData(sce.norm[top.hvg,])$gene_name) +
  exprsViolinTheme
```

The figure above reinforces clear-cut differences between cells
stimulated by bacterial infection or exposure and `uninfected` cells.

# Expression heatmap {.tabset}

We may then visualise normalised and scaled expression values in
a heat map manually organised by phenotype, while allowing genes with similar
expression profiles to cluster.

Let us first subset the normalised data set to retain only endogenous features:

```{r excludeERCC}
sce.endo <- sce.norm[!fData(sce.norm)$is_feature_control_ERCC,]
dim(sce.endo)
```

In addition, let us also reorder samples by `Time`, `Status`, and `Infection`,
to facilitate interpretation of the expression data:

```{r orderSamples}
sce.endo <- sce.endo[,with(pData(sce.endo), order(Time, Status, Infection))]
dim(sce.endo)
```

We may now examine the expression data of the ``r nrow(sce.endo)``
endogenous HVGs identified [above](#identifyHVGs):

```{r topHVG.norm}
hvg.endo <- norm_exprs(sce.endo)[rownames(hvg.out),]
dim(hvg.endo)
```

Let us prepare colours to indicate phenotype levels:

```{r palette9}
col9 <- RColorBrewer::brewer.pal(10, "Set3")[c(1:8, 10)]
```

In preparation for the heat map, let us define an annotation panel
that indicates key phenotype levels for each cell:

```{r h_column}
h_column <- HeatmapAnnotation(
  df = pData(sce.endo)[,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
```

Let us first cluster HVGs according to their expression profile across *all*
single cells:

```{r hvg.endo.clust}
hvg.endo.d <- dist(hvg.endo)
hvg.endo.clust <- hclust(hvg.endo.d)
rm(hvg.endo.d)
```

We may immediately produce a heat map that uses the above gene clustering,
while grouping samples arbitrarily according to their respective
`Time`, `Status`, and `Infection` phenotype:

```{r heatmap_supervised}
ht_supervised <- Heatmap(
  hvg.endo,
  name = "norm_exprs", column_title = "Normalised expression",
  top_annotation = h_column,
  row_order = hvg.endo.clust$order,
  cluster_rows = hvg.endo.clust, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

Now, let us cluster single cells according to their expression profile,
*within each of the experimental groups* (*i.e.*, `Time:Infection:Status`):

```{r sample.order}
sample.order <- c()
expGroups <- unique(pData(sce.endo)[,c("Time","Infection","Status")])
expGroups <- arrange(expGroups, Time, Status, Infection)
for (groupIndex in seq_len(nrow(expGroups))){
  time <- expGroups$Time[groupIndex]
  infection <- expGroups$Infection[groupIndex]
  status <- expGroups$Status[groupIndex]
  sample.index <- with(pData(sce.endo), which(
    Time == time & Infection == infection & Status == status
  ))
  hvg.sample.d <- dist(t(hvg.endo[,sample.index]))
  local.order <- sample.index[hclust(hvg.sample.d)$order]
  sample.order <- c(sample.order, local.order)
  rm(sample.index, local.order, time, infection, status)
}
rm(expGroups, groupIndex)
```

We may then produce a heat map that uses the above semi-supervised sample
clustering in combination with the earlier gene clustering, to reveal potential
sub-structure within the otherwise homogeneous experimental groups:

```{r heatmap_semiSupervised}
ht_semisupervised <- Heatmap(
  hvg.endo,
  name = "norm_exprs", column_title = "Normalised expression",
  top_annotation = h_column,
  row_order = hvg.endo.clust$order, column_order = sample.order,
  cluster_rows = hvg.endo.clust, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

Let us use the [goseq](http://bioconductor.org/packages/goseq) package to
identify the most enriched gene ontologies among the HVGs.
Note that we restrict the results to GO categories associated with at least
**10** genes, for robustness:

```{r GO.out}
hvgs <- as.integer(rownames(sce.endo) %in% rownames(hvg.endo))
names(hvgs) <- rownames(sce.endo)
table(hvgs)
geneLengths <- read.delim(
  "counts/WTCHG_305264_201201", row.names = 1)[,1, drop = FALSE]
pwf <- goseq::nullp(hvgs, bias.data=geneLengths[names(hvgs),], plot.fit=FALSE)
GO.out <- goseq::goseq(pwf, "hg38", "ensGene")
GO.out$ontology <- as.factor(GO.out$ontology)
GO.out.trim <- arrange(
    subset(
      GO.out,
      p.adjust(over_represented_pvalue, "BH") < 0.05 & numInCat >= 10
    ),
    over_represented_pvalue
  )
DT::datatable(
  head(GO.out.trim, 500), # restrict to top 500
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

Let us retrieve the identifier of genes associated with the most enriched
category ``r GO.out$term[1]`` with identifier ``r GO.out$category[1]``:

```{r genes.top, message=FALSE}
genes.topCategory <- unique(AnnotationDbi::select(
  org.Hs.eg.db, GO.out.trim$category[1], "ENSEMBL", "GOALL")$ENSEMBL
)
table(rownames(hvg.endo) %in% genes.topCategory)
```

In the same manner, let us also annotated genes relating to **4** more
GO categories relevant to the experimental design:

* *type I interferon signaling pathway*
  ([GO:0060337](http://amigo.geneontology.org/amigo/term/GO:0060337))
* *cell death*
  ([GO:0008219](http://amigo.geneontology.org/amigo/term/GO:0008219))
* *lipid metabolic process*
  ([GO:0006629](http://amigo.geneontology.org/amigo/term/GO:0006629))
* *regulation of sequence-specific DNA binding transcription factor activity*
  ([GO:0051090](http://amigo.geneontology.org/amigo/term/GO:0051090))

```{r genes.ifn, message=FALSE}
genes.ifn <- unique(AnnotationDbi::select(
  org.Hs.eg.db, "GO:0060337", "ENSEMBL", "GOALL")$ENSEMBL)
table(rownames(hvg.endo) %in% genes.ifn)
genes.death <- unique(AnnotationDbi::select(
  org.Hs.eg.db, "GO:0008219", "ENSEMBL", "GOALL")$ENSEMBL)
table(rownames(hvg.endo) %in% genes.death)
genes.lipid <- unique(AnnotationDbi::select(
  org.Hs.eg.db, "GO:0006629", "ENSEMBL", "GOALL")$ENSEMBL)
table(rownames(hvg.endo) %in% genes.lipid)
genes.tf <- unique(AnnotationDbi::select(
  org.Hs.eg.db, "GO:0051090", "ENSEMBL", "GOALL")$ENSEMBL)
table(rownames(hvg.endo) %in% genes.tf)
```

Let us annotate genes associated with the above GO categories on the heat map:

```{r heatmap_GO_annotations}
top_l <- rownames(hvg.endo) %in% genes.topCategory
h_top <- Heatmap(
  top_l + 0, name = GO.out.trim$term[1], col = c("0" = "white", "1" = "purple"),
  show_heatmap_legend = FALSE, width = unit(5, "mm"))
ifn_l <- rownames(hvg.endo) %in% genes.ifn
h_ifn <- Heatmap(
  ifn_l + 0, name = "Type I IFN", col = c("0" = "white", "1" = "red"),
  show_heatmap_legend = FALSE, width = unit(5, "mm"))
death_l <- rownames(hvg.endo) %in% genes.death
h_death <- Heatmap(
  death_l + 0, name = "Cell death", col = c("0" = "white", "1" = "red"),
  show_heatmap_legend = FALSE, width = unit(5, "mm"))
lipid_l <- rownames(hvg.endo) %in% genes.lipid
h_lipid <- Heatmap(
  lipid_l + 0, name = "Lipid metab.", col = c("0" = "white", "1" = "red"),
  show_heatmap_legend = FALSE, width = unit(5, "mm"))
tf_l <- rownames(hvg.endo) %in% genes.tf
h_tf <- Heatmap(
  tf_l + 0, name = "TF activity", col = c("0" = "white", "1" = "red"),
  show_heatmap_legend = FALSE, width = unit(5, "mm"))
```

## Supervised

```{r ht_supervised, fig.height=7}
draw(ht_supervised + h_top + h_ifn + h_death + h_lipid + h_tf)
```

## Semi-supervised

```{r ht_semisupervised, fig.height=7}
draw(ht_semisupervised + h_top + h_ifn + h_death + h_lipid + h_tf)
```

# Pairwise distances between samples

## Euclidian distance

### Estimate distances

Calculate the Euclidian distance between samples using the
normalised expression data calculated in a
[previous section](05_normalisation.html#normalize)
scaled (mean: **0**; standard deviation: **1**) for the
`r nrow(hvg.endo)` HVGs identified [above](#HVGs):

```{r distEuclidScaled}
hvg.scaled <- t(scale(t(hvg.endo)))
d.e.s <- dist(t(hvg.scaled), diag = TRUE, upper = TRUE)
mat.e.s <- as.matrix(d.e.s)
```

For comparison purposes, let us do the same with normalised (unscaled) values:

```{r distEuclidNorm}
d.e.n <- dist(t(hvg.endo), diag = TRUE, upper = TRUE)
mat.e.n <- as.matrix(d.e.n)
```

We may then cluster samples according to their Euclidian distance for scaled
values, using Ward's criterion to minimize the total variance within each
cluster [@67]:

```{r clustEuclidScaled}
h.e.s <- hclust(d.e.s, method = "ward.D2")
ord.e.s <- mat.e.s[h.e.s$order, h.e.s$order]
rm(mat.e.s)
```

Again, do the same for unscaled values:

```{r clustEuclidNorm}
h.e.n <- hclust(d.e.n, method = "ward.D2")
ord.e.n <- mat.e.n[h.e.n$order, h.e.n$order]
rm(mat.e.n)
```

### Heat maps {.tabset}

Draw the heat maps using Euclidian distance for normalised or
normalised-scaled data:

```{r heatEuclid}
hs_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.e.s$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
hs <- Heatmap(
  ord.e.s, name = "distance", column_title = "Normalised scaled",
  top_annotation = hs_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
hn_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.e.n$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
hn <- Heatmap(
  ord.e.n, name = "distance", column_title = "Normalised unscaled",
  top_annotation = hn_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

#### Scaled

```{r heatEuclidNorm, fig.height=6}
draw(hs)
```

#### Normalised

```{r heatEuclidScaled, fig.height=6}
draw(hn)
```

## Spearman correlation

### Estimate distances

Estimate distance between cells using Spearman's (rank) correlation.

**Note:**
The rank correlation is insensitive to the scaling process (the order
of samples are preserved by the scaling procedure). Therefore, there is
no need to compare the identical heat maps produced for the two data sets.

```{r distSpearman}
c.s <- MKmisc::corDist(t(hvg.endo), "spearman", diag = TRUE, upper = TRUE)
mat.c.s <- as.matrix(c.s)
```

Cluster samples:

```{r clustSpearman}
h.c.s <- hclust(c.s)
ord.c.s <- mat.c.s[h.c.s$order, h.c.s$order]
rm(c.s)
```

The heat map is shown along with those using Pearson correlation further
[below](#correlationHeatMaps).

## Pearson correlation

### Estimate distances

Estimate distance between cells using Pearson's correlation.
Let us compare the effect of scaling the expression data (by gene)
on the correlation between samples.

We start calculating the sample correlation using the unscaled normalised data:

```{r distPearsonNorm}
c.p.n <- MKmisc::corDist(t(hvg.endo), diag = TRUE, upper = TRUE)
mat.c.p.n <- as.matrix(c.p.n)
```

We then do the same with the scaled data:

```{r distPearsonScaled}
c.p.s <- MKmisc::corDist(t(hvg.scaled), diag = TRUE, upper = TRUE)
mat.c.p.s <- as.matrix(c.p.s)
```

Cluster samples using Pearson's correlation for the unscaled data:

```{r clustPearsonNorm}
h.c.p.n <- hclust(c.p.n)
ord.c.p.n <- mat.c.p.n[h.c.p.n$order, h.c.p.n$order]
rm(c.p.n)
```

And the same for the scaled data:

```{r clustPearsonScaled}
h.c.p.s <- hclust(c.p.s)
ord.c.p.s <- mat.c.p.s[h.c.p.s$order, h.c.p.s$order]
rm(c.p.s)
```

### Heat maps {#correlationHeatMaps .tabset}

Let us prepare the heat map using Spearman's $\rho$ correlation:

```{r heatSpearman}
ht_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.c.s$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
ht_s <- Heatmap(
  ord.c.s, name = "distance", column_title = "Spearman distance",
  top_annotation = ht_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

Followed by the heat maps using Pearson's _r_ correlation
(*i.e.*, normalised, and normalised scaled):

```{r heatPearson}
hn_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.c.p.n$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
ht_pn <- Heatmap(
  ord.c.p.n, name = "distance", column_title = "Normalised unscaled",
  top_annotation = hn_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
hs_column <- HeatmapAnnotation(
  df = pData(sce.endo)[h.c.p.s$order,c("Time", "Status", "Infection")],
  col = list(
    Time = c("2h" = col9[1], "4h" = col9[2], "6h" = col9[3]),
    Status=c("uninfected"=col9[4],"exposed"=col9[5],"infected"=col9[6]),
    Infection = c("Mock" = col9[7], "LT2" = col9[8], "D23580" = col9[9])
  )
)
ht_ps <- Heatmap(
  ord.c.p.s, name = "distance", column_title = "Normalised scaled",
  top_annotation = hs_column,
  cluster_rows = FALSE, cluster_columns = FALSE,
  show_row_names = FALSE, show_column_names = FALSE
)
```

#### Spearman

```{r ht_s, fig.height=6}
draw(ht_s)
```

#### Pearson (normalised)

```{r heatPearsonNorm, fig.height=6}
draw(ht_pn)
```

#### Pearson (scaled)

```{r heatPearsonScaled, fig.height=6}
draw(ht_ps)
```

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->

```{r saveRDS, include=FALSE}
saveRDS(hvg.out, "rds/hvg.out.rds")
```

# HVGs within experimental groups

## Identification {#HVGsWithinGroups}

Similarly to the above identification of HVGs across cells (driven primarily
by a strong effect of the `Time` factor), let us identify HVGs within each
experimental group of cells:

```{r HVGs.group, warning=FALSE, message=FALSE, fig.height=9, results='hold'}
par(mfrow=c(5,3))
dVar.groups <- list()
HVGs.group <- list()
for (group in levels(sce.norm$Group)){
  idx.group <- which(sce.norm$Group == group)
  # message(group); message(sprintf("# samples: %i", length(idx.group)))
  dm <- model.matrix(~Plate+Lane, data = pData(sce.norm)[idx.group,])
  var.fit.endo <- trendVar(
    sce.norm[,idx.group], assay = "norm_exprs", trend = "loess", design = dm,
    use.spikes = FALSE, span = 0.1
  )
  var.out.endo <- decomposeVar(sce.norm[,idx.group], var.fit.endo)
  ## Optional check: to compare spike-in variances.
  plot(
    var.out.endo$mean, var.out.endo$total, pch=16, cex=0.2,
    xlab="Mean log-expression", ylab="Variance of log-expression",
    main = group
  )
  o <- order(var.out.endo$mean)
  lines(var.out.endo$mean[o], var.out.endo$tech[o], col="dodgerblue", lwd=2)
  spike.fit <- trendVar(sce.norm[,idx.group], use.spikes=TRUE)
  points(spike.fit$mean, spike.fit$var, col="red", pch=16, cex=0.4)
  #var.out.endo <- var.out.endo[order(var.out.endo$bio, decreasing=TRUE),]
  var.out.endo <- cbind(
    Symbol = mapIds(EnsDb.Hsapiens.v79, rownames(var.out.endo), "GENENAME", "GENEID"),
    var.out.endo
  )
  write.csv(var.out.endo, sprintf("HVGs/%s_full.csv", group))
  dVar.groups[[group]] <- var.out.endo
  hvg.out <- var.out.endo[which(
    var.out.endo$FDR <= 0.05 & var.out.endo$bio >= 0.5
    ),]
  write.csv(hvg.out, sprintf("HVGs/%s_significant.csv", group))
  HVGs.group[[group]] <- hvg.out
}
par(mfrow=c(1,1))
```

Note how, in the stimulated cells, the mean-variance trend shifts to the right
over time, with increasing variability of moderately to highly expressed genes
at later time points.
In particular, an interesting set of about a dozen of genes appears to be both
highly expressed (mean log-expression > 10) and
highly variable (markedly above the trend of estimated technical variance for
most genes; blue line) in all groups of stimulated cells.
This subset of genes is further investigated below, as they may represent
key genes 

## Highly expressed HVGs at 6h {.tabset}

For each group of stimulated cells, the aforementioned sets of highly expressed
and highly variable gene features are listed below and their distribution
of expression levels displayed in the last tab:

### 6h_D23580_exposed

```{r 6h_D23580_exposed}
HVG_D23_exp <- subset(HVGs.group[["6h_D23580_exposed"]], mean > 10 & bio > 5)
DT::datatable(HVG_D23_exp)
```

### 6h_LT2_exposed

```{r 6h_LT2_exposed}
HVG_LT2_exp <- subset(HVGs.group[["6h_LT2_exposed"]], mean > 10 & bio > 5)
DT::datatable(HVG_LT2_exp)
```

### 6h_D23580_infected

```{r 6h_D23580_infected}
HVG_D23_inf <- subset(HVGs.group[["6h_D23580_infected"]], mean > 10 & bio > 5)
DT::datatable(HVG_D23_inf)
```

### 6h_LT2_infected

```{r 6h_LT2_infected}
HVG_LT2_inf <- subset(HVGs.group[["6h_LT2_infected"]], mean > 10 & bio > 5)
DT::datatable(HVG_LT2_inf)
```

### Melt

This chunk of code melts the normalised expression data into a `data.frame`
plotted in the next tab:

```{r normExprsMelt}
normExprsMelt <- reshape2::melt(
  norm_exprs(sce.norm)[,sce.norm$Time == "6h" & sce.norm$Infection != "Mock"],
  varnames = c("Feature","Sample"), value.name = "norm_exprs")
normExprsMelt <- merge(normExprsMelt, pData(sce.norm)[,c("Sample","Treatment")])
normExprsMelt <- subset(
  normExprsMelt, Feature %in% unique(c(
    rownames(HVG_D23_exp),
    rownames(HVG_LT2_exp),
    rownames(HVG_D23_inf),
    rownames(HVG_LT2_inf)))
  )
normExprsMelt <- merge(
  normExprsMelt, data.frame(
    Feature = featureNames(sce.norm), gene_name = fData(sce.norm)$gene_name)
  )
```

### CCL22

At 6h, gene *CCL22* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `D23 exposed`

```{r CCL22}
ggplot(subset(normExprsMelt, gene_name == "CCL22")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### CTSB

At 6h, gene *CTSB* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `D23 exposed`

```{r CTSB}
ggplot(subset(normExprsMelt, gene_name == "CTSB")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### SAT1

At 6h, gene *SAT1* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `D23 exposed`

```{r SAT1}
ggplot(subset(normExprsMelt, gene_name == "SAT1")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### TNFAIP2

At 6h, gene *TNFAIP2* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `D23 exposed`

```{r TNFAIP2}
ggplot(subset(normExprsMelt, gene_name == "TNFAIP2")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### CD83

At 6h, gene *CD83* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `D23 exposed`

```{r CD83}
ggplot(subset(normExprsMelt, gene_name == "CD83")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### ACTG1

At 6h, gene *ACTG1* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `D23 exposed`

```{r ACTG1}
ggplot(subset(normExprsMelt, gene_name == "ACTG1")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### SLAMF7

At 6h, gene *SLAMF7* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `LT2 exposed`

```{r SLAMF7}
ggplot(subset(normExprsMelt, gene_name == "SLAMF7")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### NFKBIA

At 6h, gene *NFKBIA* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `LT2 exposed`

```{r NFKBIA}
ggplot(subset(normExprsMelt, gene_name == "NFKBIA")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### LDHA

At 6h, gene *LDHA* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `LT2 exposed`

```{r LDHA}
ggplot(subset(normExprsMelt, gene_name == "LDHA")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### SLC2A3

At 6h, gene *SLC2A3* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `LT2 exposed`

```{r SLC2A3}
ggplot(subset(normExprsMelt, gene_name == "SLC2A3")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### TIMP1

At 6h, gene *TIMP1* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `D23 infected`

```{r TIMP1}
ggplot(subset(normExprsMelt, gene_name == "TIMP1")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### RSAD2

At 6h, gene *RSAD2* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `D23 infected`

```{r RSAD2}
ggplot(subset(normExprsMelt, gene_name == "RSAD2")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### SPP1

At 6h, gene *SPP1* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `D23 infected`

```{r SPP1}
ggplot(subset(normExprsMelt, gene_name == "SPP1")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### ANXA1

At 6h, gene *ANXA1* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `LT2 infected`

```{r ANXA1}
ggplot(subset(normExprsMelt, gene_name == "ANXA1")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### ATF3

At 6h, gene *ATF3* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `LT2 infected`

```{r ATF3}
ggplot(subset(normExprsMelt, gene_name == "ATF3")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### PMAIP1

At 6h, gene *PMAIP1* was identified as HVG (`bio > 0.5`; `FDR < 0.05`) and
highly expressed (`norm_exprs > 10`) in group `LT2 infected`

```{r PMAIP1}
ggplot(subset(normExprsMelt, gene_name == "PMAIP1")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```


### All

```{r}
ggplot(normExprsMelt) + facet_wrap(~Treatment) +
  geom_density(aes(norm_exprs, colour = gene_name), alpha = 0.5)
```

## TNFAIP2 over time {.tabset}

In this section, let us examine more closely how the distribution
of *TNFAIP2* expression levels evolves over time within each
experimental group of stimulated cells:

### Melt

This chunk of code melts the normalised expression data for *TNFAIP2*
into a `data.frame` plotted in the next tabs:

```{r TNFAIP2normExprsMelt}
TNFAIP2normExprsMelt <- reshape2::melt(
  norm_exprs(sce.norm)[
    mapIds(EnsDb.Hsapiens.v79, "TNFAIP2", "GENEID", "GENENAME"),
    sce.norm$Infection != "Mock", drop=FALSE
  ],
  varnames = c("Feature","Sample"), value.name = "norm_exprs")
TNFAIP2normExprsMelt <- merge(
  TNFAIP2normExprsMelt, pData(sce.norm)[,c("Sample","Treatment","Time")])
TNFAIP2normExprsMelt <- merge(
  TNFAIP2normExprsMelt, data.frame(
    Feature = featureNames(sce.norm), gene_name = fData(sce.norm)$gene_name)
  )
```

### 2h

```{r TNFAIP2_2h}
ggplot(subset(TNFAIP2normExprsMelt, Time == "2h")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### 4h

```{r TNFAIP2_4h}
ggplot(subset(TNFAIP2normExprsMelt, Time == "4h")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

### 6h

```{r TNFAIP2_6h}
ggplot(subset(TNFAIP2normExprsMelt, Time == "6h")) +
  geom_density(aes(norm_exprs)) + facet_wrap(~Treatment)
```

## Technical noise fit

We may also plot the biological component of variance against the mean
normalised expression level (log-count) of each gene in each group.

For this, let us first estimate the technical coefficient of variation as a
function of the mean using the [scran](http://bioconductor.org/packages/scran)
`technicalCV2` function for each group of cells:

```{r CV2data, fig.height=9}
CV2data <- data.frame()
for (groupName in names(dVar.groups)){
  techCV2 <- technicalCV2(
    sce.norm[,sce.norm$Group == groupName], spike.type = "ERCC", assay = "counts")
  geneNames <- rownames(techCV2)
  CV2data <- rbind(CV2data, data.frame(
    CV2 = techCV2$cv2,
    meanScaledCount = techCV2$mean,
    trend = techCV2$trend,
    HVG = geneNames %in% rownames(HVGs.group[[groupName]]),
    Time = gsub("(.*h)_.*", "\\1", groupName),
    Treatment = gsub(".*h_(.*)", "\\1", groupName),
    Feature = geneNames
  ))
}
```

We may then display the estimated $CV^2$ against the average scaled read count,
while indicating the fitted variance-mean dependence (solid red curve), and
the HVGs detected [earlier](#HVGsWithinGroups)

```{r CV2plot, warning=FALSE, fig.height=7}
ggplot(CV2data) +
  geom_point(aes(meanScaledCount, CV2, colour = HVG), size = 0.2, alpha = 0.3) +
  geom_smooth(
    aes(meanScaledCount, CV2, fill = HVG), colour = "dimgray",
    size = 0.5, alpha = 0.5) +
  scale_x_log10() + scale_y_log10() +
  facet_grid(Treatment ~ Time) +
  theme(legend.text = element_text(size=7), legend.title = element_text(size=7))
```


```{r vennExport, include=FALSE}
# Export Venn diagram figures
for (time in levels(sce.norm$Time)){
  groupNames <- grep(time, names(HVGs.group), value = TRUE)
  hvgsList <- lapply(HVGs.group[groupNames], rownames)
  names(hvgsList) <- gsub(paste0(time,"_"), "", names(hvgsList))
  #venn.diagram(hvgsList, filename = sprintf("HVGs/%s_venn.tiff", time))
  pdf(sprintf("HVGs/%s_venn.pdf", time), width = 6, height = 6)
  venn(hvgsList)
  dev.off()
}
```

Let us visualise the count of HVGs identified in each experimental group:

```{r countHVGsByGroup}
groupNames <- levels(sce.norm$Group)
hvgsPerGroup <- data.frame(
  Group = groupNames,
  HVGs = sapply(groupNames, function(groupName){nrow(HVGs.group[[groupName]])}),
  Time = gsub("(.*)_.*_.*", "\\1", groupNames),
  Infection = gsub(".*_(.*)_.*", "\\1", groupNames),
  Status = gsub(".*_.*_(.*)", "\\1", groupNames),
  Treatment = gsub(".*h_(.*)", "\\1", groupNames)
)
ggplot(hvgsPerGroup) + geom_col(aes(Treatment, HVGs, alpha = Time, colour = Infection)) +
  theme(
    axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5),
    axis.ticks.x = element_blank(), panel.background = element_blank(),
    axis.title.x = element_blank()
  ) +
  facet_grid(. ~ Time)
```

# References
