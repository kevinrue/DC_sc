---
title: "Feature selection"
bibliography:
  bibtex.bib
---

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scater)
library(edgeR)
library(ggplot2)
library(SummarizedExperiment)
sce.pass <- readRDS("rds/sce.pass.rds")
sce.bulk <- readRDS("rds/sce.bulk.rds")
gtfData <- readRDS("rds/gtfData.rds")
mixC <- readRDS("rds/mixC.rds")
ERCCs <- grep("^ERCC-[[:digit:]]+$", featureNames(sce.pass), value = TRUE)
MTs <- mcols(gtfData)[seqnames(gtfData) == "MT", "gene_id"]
```

# Correlation of bulks and single cell average {.tabset}

For each experimental group of single cells, let us calculate the average
expression level (`log2(counts+1)`) of each feature:

```{r}
bulkSCdata <- list()
for (groupName in levels(sce.pass$Group)){
  time <- gsub("^(.*h)_.*", "\\1", groupName)
  infection <- gsub(".*_(.*)_.*", "\\1", groupName) 
  cellIndex <- which(sce.pass$Group == groupName)
  cellAvg <- rowMeans(exprs(sce.pass[,cellIndex]))
  bulkExpr <- exprs(sce.bulk)[,which(
    sce.bulk$Time == time & sce.bulk$Infection == infection
    )]
  geneNames <- names(cellAvg)
  bulkSCdata[[groupName]] <- data.frame(
    Cells = cellAvg[geneNames], Bulk = bulkExpr, row.names = geneNames
  )
}
```

We may then display the average expression level of each gene within each
experimental group of single cells against their matched bulk sample.

Importantly, stimulated bulk samples are expected to be a mixture of
`infected` and `exposed` cells. We may therefore compare the average expression
in each subset of cells against the bulk average, to identify potential
differences:

## 2h_Mock_uninfected

```{r 2h_Mock_uninfected}
ggplot(bulkSCdata[["2h_Mock_uninfected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_Mock_uninfected

```{r 4h_Mock_uninfected}
ggplot(bulkSCdata[["4h_Mock_uninfected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_Mock_uninfected

```{r 6h_Mock_uninfected}
ggplot(bulkSCdata[["6h_Mock_uninfected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 2h_D23580_exposed

```{r 2h_D23580_exposed}
ggplot(bulkSCdata[["2h_D23580_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_D23580_exposed

```{r 4h_D23580_exposed}
ggplot(bulkSCdata[["4h_D23580_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_D23580_exposed

```{r 6h_D23580_exposed}
ggplot(bulkSCdata[["6h_D23580_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 2h_LT2_exposed

```{r 2h_LT2_exposed}
ggplot(bulkSCdata[["2h_LT2_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_LT2_exposed

```{r 4h_LT2_exposed}
ggplot(bulkSCdata[["4h_LT2_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_LT2_exposed

```{r 6h_LT2_exposed}
ggplot(bulkSCdata[["6h_LT2_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 2h_D23580_infected

```{r 2h_D23580_infected}
ggplot(bulkSCdata[["2h_D23580_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_D23580_infected

```{r 4h_D23580_infected}
ggplot(bulkSCdata[["4h_D23580_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_D23580_infected

```{r 6h_D23580_infected}
ggplot(bulkSCdata[["6h_D23580_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 2h_LT2_infected

```{r 2h_LT2_infected}
ggplot(bulkSCdata[["2h_LT2_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_LT2_infected

```{r 4h_LT2_infected}
ggplot(bulkSCdata[["4h_LT2_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_LT2_infected

```{r 6h_LT2_infected}
ggplot(bulkSCdata[["6h_LT2_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

# Overview of feature detection levels

Having selected single cells that pass all quality control criteria in the
previous sections, let us identify features that are robustly detected across
single cells in the data set.
Indeed, features detected in a small count of cells, or expressed at very
low levels carry limited information for differential expression analyses;
moreover, those features negatively affect the performance of normalisation
algorithms, due to the large number of dropout (*i.e.*, zero count) events
[@67; @Brennecke_2013].

First, let us initalise the matrix of CPM:

```{r cpm}
scater::cpm(sce.pass) <- edgeR::cpm(counts(sce.pass))
range(colSums(cpm(sce.pass)))
```

## Detection frequency and mean expression level

For this purpose, let us first calculate updated QC metrics in the subsetted
data set using once more the [scater](http://bioconductor.org/packages/scater)
`calculateQCMetrics` method:

```{r pass_calculateQCMetrics}
sce.pass <- calculateQCMetrics(
  sce.pass, feature_controls = list(ERCC = ERCCs, MT = MTs)
)
```

We may then examine for each feature the proportion of cells in which it is
detected (non-zero expression level) against its average expression level
across all cells:

```{r plotExprsFreqVsMean}
plotExprsFreqVsMean(
  sce.pass,
  feature_controls = fData(sce.pass)$is_feature_control_ERCC
)
```

## Spike-in expectations

Let us compare the expected number of spike-in molecules introduced in each
sample (calculated in this [section](00b_moleculesERCC.html)), against the
average count detected across all single cells:

```{r ERCCcorrelation, warning=FALSE}
mixC$avgCount <- rowMeans(counts(sce.pass)[mixC$ID,])
names(mixC)
maxPlot <- max(mixC$avgCount, mixC$ERCCmolecules)
ggplot(mixC) + geom_point(aes(ERCCmolecules, avgCount)) +
  labs(x = "ERCC molecules injected", y = "Average count in cells passed QC") +
  scale_x_log10() + scale_y_log10() + coord_fixed(ratio = 1)
```

# Definition of detected feature {.tabset}

Let us examine the distribution of log-mean CPM across all genes, while
indicating an average value of **1** CPM:

```{r detectVsMean_hist}
ave.cpm <- rowMeans(scater::cpm(sce.pass))
hist(
  log10(ave.cpm), breaks = 100,
  main = "", xlab = expression(Log[10]~"average CPM", col="grey80")
)
abline(v = log10(1), col = "blue", lwd = 2, lty = 2)
```

We may compare the above figure with the a smoother representation of the
count of cells in which each feature is detected against the average
log~10~-transformed count of reads assigned to that same feature, while
marking the same cut-off threshold of an average **1** count across all cells:

```{r smoothScatter}
numcells <- nexprs(sce.pass, byrow = TRUE)
is.ercc <- fData(sce.pass)$is_feature_control_ERCC
smoothScatter(
  log10(ave.cpm), numcells, xlab=expression(Log[10]~"average CPM"),
  ylab="Number of expressing cells"
)
points(
  log10(ave.cpm[is.ercc]), numcells[is.ercc],
  col = "red", pch = 16, cex = 0.5
)
abline(v = log10(1), col = "blue", lwd = 2, lty = 2)
```

In the context of the present multifactorial experimental design, let us define
informative endogenous features as those with an average count above a
threshold of **20** counts per million (CPM) in at least **1** experimental
group of cells (`r min(table(sce.pass$Group))`-`r max(table(sce.pass$Group))`
cells per group, after exclusion of outliers).
In contrast, let us define informative spike-in features
as those with an average count greater or equal to a threhsold of **1** count.
Note that the count of cells per group was reported
[here](03_sampleQC#cellSelection)

Let us first calculate the average CPM for each gene within each experimental
group:

**Note:** Make sure to use `scater::cpm` (*not* `edge::cpm`) below, to
*access* the `cpm` matrix of the `assayData` slot; otherwise a new CPM matrix
may be inappropriately calculated.

```{r avgCPMbyGroup}
avgCPMbyGroup <- apply(scater::cpm(sce.pass), 1, function(x){
  tapply(x, sce.pass$Group, mean)
})
avgCPMbyGroup <- reshape2::melt(
  avgCPMbyGroup, varnames = c("Group", "Feature"), value.name = "AvgCPM")
```

Let us examine the proportion of gene features expressed at various levels in 
each experimental groups:

```{r}
zeroCounts <- data.frame(
  Group = levels(avgCPMbyGroup$Group),
  y = 1E-2,
  Count = with(avgCPMbyGroup, tapply(AvgCPM, Group, function(x){sum(x>0)}))
)
avgCPMbyGroup$Time = gsub("^(.*h)_.*", "\\1", avgCPMbyGroup$Group)
avgCPMbyGroup$Infection = factor(
  gsub(".*_(.*)_.*", "\\1", avgCPMbyGroup$Group), c("D23580","LT2","Mock"))
avgCPMbyGroup$Status = factor(
  gsub(".*_(.*)$", "\\1", avgCPMbyGroup$Group), c("infected","exposed","uninfected"))
```

The figure below indicates the three quartiles for each experimental group,
*after removal of features with zero counts
(indicated in the label displayed at the bottom of each violin)*.
For instance, generally ~30% of "detectable" features are
found below 1 CPM (across all cells that passed QC filtering),
while ~50-60% of features are detected above 10 CPM:

```{r violinAvgCPMbyGroup, warning=FALSE}
ggplot(avgCPMbyGroup, aes(Group, AvgCPM)) +
  geom_violin(draw_quantiles = seq(0.25, 0.75, 0.25)) +
  geom_label(aes(Group, y, label = Count), data = zeroCounts, size = 2) +
  scale_y_log10(limits = c(1E-2, 1E5)) +
  theme(
    axis.text.x = element_text(angle = 90), panel.grid.major.x = element_blank()
  )
```

Let us now count and display for each feature the number of experimental groups
with an average CPM above various threshold:

```{r}
cutoffs <- c(10,20,50,100)
groupsAboveCPM <- as.data.frame(sapply(
  cutoffs,
  function(cutoff){
    with(avgCPMbyGroup, tapply(AvgCPM, Feature, function(x){sum(x > cutoff)}))
  }
))
colnames(groupsAboveCPM) <- paste0("cpm", cutoffs)
axisLabels <- labs(x="Feature index",y="Count of groups above CPM cutoff")
```

Let us remove ERCC spike-in identifiers from this table, as their detection
level is not expected to vary between experimental conditions:

```{r rmERCCcpm}
endoGroupsAboveCPM <- subset(
  groupsAboveCPM, !grepl("^ERCC-",rownames(groupsAboveCPM)))
cpmIndex <- seq_len(nrow(endoGroupsAboveCPM))
```

## 10 CPM

```{r endoGroupsAbove10cpm}
ggplot(endoGroupsAboveCPM) + axisLabels +
  geom_line(aes(cpmIndex, sort(cpm10, decreasing=TRUE)))
```

`r sum(endoGroupsAboveCPM$cpm10 >= 1)` endogenous features have an average CPM
above **10** in at least **1** experimental group.

## 20 CPM

```{r groupsAbove20cpm}
ggplot(endoGroupsAboveCPM) + axisLabels +
  geom_line(aes(cpmIndex, sort(cpm20, decreasing=TRUE)))
```

`r sum(endoGroupsAboveCPM$cpm20 >= 1)` endogenous features have an average CPM
above **20** in at least **1** experimental group.

## 50 CPM

```{r endoGroupsAbove50cpm}
ggplot(endoGroupsAboveCPM) + axisLabels +
  geom_line(aes(cpmIndex, sort(cpm50, decreasing=TRUE)))
```

`r sum(endoGroupsAboveCPM$cpm50 >= 1)` endogenous features have an average CPM above
**50** in at least **1** experimental group.

## 100 CPM

```{r endoGroupsAbove100cpm}
ggplot(endoGroupsAboveCPM) + axisLabels +
  geom_line(aes(cpmIndex, sort(cpm100, decreasing=TRUE)))
  axisLabels
```

`r sum(endoGroupsAboveCPM$cpm100 >= 1)` endogenous features have an average CPM above
**100** in at least **1** experimental group.

# Selection of detected features {#selectFeatures}

Following the above observations, let us retain for further analysis:

* endogenous features detected at an average level greater than **20** CPM in
  **≥ 1** experimental group,
* ERCC spike-in features detected at an average level greater than **1** count
  across all cells:

```{r detectedFeatures}
stopifnot(all(rownames(groupsAboveCPM) == rownames(sce.pass)))
keepEndogenous <- (groupsAboveCPM[,"cpm20"] >= 1) & (!isSpike(sce.pass))
keepSpike <- (rowMeans(counts(sce.pass)) > 1) & (isSpike(sce.pass))
table(keepEndogenous); table(keepSpike)
```

```{r sce.filtered}
sce.filtered <- sce.pass[keepEndogenous | keepSpike,]
dim(sce.filtered)
```


To facilitate later interpretation, let us annotate endogenous feature
identifiers in the `SCESet` with gene symbols extracted from the same GTF file
that was supplied to _featureCounts_ for quantitation:

```{r annotateSymbol_sce.filtered}
fData(sce.filtered)$gene_name <-
  gtfData$gene_name[match(rownames(sce.filtered), gtfData$gene_id)]
```

# References

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->

```{r save_sce.pass, include=FALSE}
saveRDS(sce.filtered, "rds/sce.filtered.rds")
```
