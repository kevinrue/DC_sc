---
title: "Feature selection"
bibliography:
  bibtex.bib
---

```{r checkPkgs, child="_checkLibraries.Rmd", include=FALSE}
```

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scater)
library(SummarizedExperiment)
sce.pass <- readRDS("rds/sce.pass.rds")
gtfData <- readRDS("rds/gtfData.rds")
mixC <- readRDS("rds/mixC.rds")
ERCCs <- grep("^ERCC-[[:digit:]]+$", featureNames(sce.pass), value = TRUE)
MTs <- mcols(gtfData)[seqnames(gtfData) == "MT", "gene_id"]
```

# Overview of feature detection levels

Having selected single cells that pass all quality control criteria in the
previous sections, let us identify features that are robustly detected across
single cells in the data set.
Indeed, features detected in a small count of cells, or expressed at very
low levels carry limited information for differential expression analyses;
moreover, those features negatively affect the performance of normalisation
algorithms, due to the large number of dropout (*i.e.*, zero count) events
[@67; @Brennecke_2013].

First, let us initalise the matrix of CPM:

```{r cpm}
libSizes <- colSums(counts(sce.pass)) / 1E6
cpm(sce.pass) <- t(t(counts(sce.pass)) / libSizes)
range(colSums(cpm(sce.pass)))
```

## Detection frequency and mean expression level

For this purpose, let us first calculate updated QC metrics in the subsetted
data set using once more the [scater](http://bioconductor.org/packages/scater)
`calculateQCMetrics` method:

```{r pass_calculateQCMetrics}
sce.pass <- calculateQCMetrics(
  sce.pass, feature_controls = list(ERCC = ERCCs, MT = MTs)
)
```

We may then examine for each feature the proportion of cells in which it is
detected (non-zero expression level) against its average expression level
across all cells:

```{r plotExprsFreqVsMean}
plotExprsFreqVsMean(
  sce.pass,
  feature_controls = fData(sce.pass)$is_feature_control_ERCC
)
```

## Spike-in expectations

Let us compare the expected number of spike-in molecules introduced in each
sample (calculated in this [section](00b_moleculesERCC.html)), against the
average count detected across all single cells:

```{r ERCCcorrelation}
mixC$avgCount <- rowMeans(counts(sce.pass)[mixC$ID,])
names(mixC)
maxPlot <- max(mixC$avgCount, mixC$ERCCmolecules)
ggplot(mixC) + geom_point(aes(ERCCmolecules, avgCount)) +
  labs(x = "ERCC molecules injected", y = "Average count in cells passed QC") +
  scale_x_log10() + scale_y_log10() + coord_fixed(ratio = 1)
```

# Definition of detected feature {.tabset}

Let us examine the distribution of log-mean CPM across all genes, while
indicating an average value of 10 CPM:

```{r detectVsMean_hist}
ave.cpm <- rowMeans(cpm(sce.pass))
hist(
  log10(ave.cpm), breaks = 100,
  main = "", xlab = expression(Log[10]~"average CPM", col="grey80")
)
abline(v = log10(1), col = "blue", lwd = 2, lty = 2)
```

We may compare the above figure with the a smoother representation of the
count of cells in which each feature is detected against the average
log~10~-transformed count of reads assigned to that same feature, while
marking the same cut-off threshold of an average $1$ count across all cells:

```{r smoothScatter}
numcells <- nexprs(sce.pass, byrow = TRUE)
is.ercc <- fData(sce.pass)$is_feature_control_ERCC
smoothScatter(
  log10(ave.cpm), numcells, xlab=expression(Log[10]~"average CPM"),
  ylab="Number of expressing cells"
)
points(
  log10(ave.cpm[is.ercc]), numcells[is.ercc],
  col = "red", pch = 16, cex = 0.5
)
abline(v = log10(1), col = "blue", lwd = 2, lty = 2)
```

In the context of the present multifactorial experimental design,
let us define informative features as those with an average count above a
threshold of 20 counts per million (CPM) in at least one experimental group of
cells (`r min(table(sce.pass$Group))`-`r max(table(sce.pass$Group))` cells
per group):

```{r tableGroup, echo=FALSE}
datatable(
  as.data.frame(sort(table(sce.pass$Group)), row.names = 1),
  options = list(pageLength = 15)
)
```

Let us first calculate the average CPM for each gene within each experimental
group:

```{r avgCPMbyGroup}
avgCPMbyGroup <- apply(cpm(sce.pass), 1, function(x){
  tapply(x, sce.pass$Group, mean)
})
avgCPMbyGroup <- reshape2::melt(
  avgCPMbyGroup, varnames = c("Group", "Feature"), value.name = "AvgCPM")
```

Let us examine the proportion of gene features expressed at various levels in 
each experimental groups. The figure below indicates the 9 deciles for
each experimental group, *after removal of features with zero counts*.
For instance, generally ~30% of "detectable" features are
found below 1 CPM (across all cells that passed QC filtering),
while ~50-60% of features are detected above 10 CPM:

```{r violinAvgCPMbyGroup}
zeroCounts <- data.frame(
  Group = levels(avgCPMbyGroup$Group),
  y = 1E-2,
  Count = with(avgCPMbyGroup, tapply(AvgCPM, Group, function(x){sum(x>0)}))
)
ggplot(avgCPMbyGroup, aes(Group, AvgCPM)) +
  geom_violin(draw_quantiles = seq(0.25, 0.75, 0.25)) +
  geom_label(aes(Group, y, label = Count), data = zeroCounts, size = 2) +
  scale_y_log10(limits = c(1E-2, 1E5)) +
  theme(axis.text.x = element_text(angle = 90))
```

Let us now count and display for each feature the number of experimental groups
with an average CPM above various threshold:

```{r}
cutoffs <- c(10,20,50,100)
groupsAboveCPM <- as.data.frame(sapply(
  cutoffs,
  function(cutoff){
    with(avgCPMbyGroup, tapply(AvgCPM, Feature, function(x){sum(x > cutoff)}))
  }
))
colnames(groupsAboveCPM) <- paste0("cpm", cutoffs)
axisLabels <- labs(x="Feature index",y="Count of groups above CPM cutoff")
```

## 20 CPM

```{r groupAbove20cpm}
ggplot(groupsAboveCPM) +
  geom_line(aes(seq_len(nrow(groupsAboveCPM)), sort(cpm20, decreasing=TRUE))) +
  axisLabels
```

`r sum(groupsAboveCPM$cpm20 >= 1)` features have an average CPM above 20 in at
least one experimental group.

## 10 CPM

```{r groupAbove10cpm}
ggplot(groupsAboveCPM) +
  geom_line(aes(seq_len(nrow(groupsAboveCPM)), sort(cpm10, decreasing=TRUE))) +
  axisLabels
```

`r sum(groupsAboveCPM$cpm10 >= 1)` features have an average CPM above 10 in at
least one experimental group.

## 50 CPM

```{r groupAbove50cpm}
ggplot(groupsAboveCPM) +
  geom_line(aes(seq_len(nrow(groupsAboveCPM)), sort(cpm50, decreasing=TRUE))) +
  axisLabels
```

`r sum(groupsAboveCPM$cpm50 >= 1)` features have an average CPM above 50 in at
least one experimental group.

## 100 CPM

```{r groupAbove100cpm}
ggplot(groupsAboveCPM) +
  geom_line(aes(seq_len(nrow(groupsAboveCPM)), sort(cpm100, decreasing=TRUE))) +
  axisLabels
```

`r sum(groupsAboveCPM$cpm100 >= 1)` features have an average CPM above 100 in at
least one experimental group.

# Selection of detected features {#selectFeatures}

Following the above observations, let us retain for further analysis
features detected at an average level of at least 20 CPM in at least
one experimental group:

```{r ave.counts}
keep <- groupAbove20cpm >= 1
sce.filtered <- sce.pass[names(which(keep)),]
dim(sce.filtered)
```

To facilitate later interpretation, let us annotate endogenous feature
identifiers in the `SCESet` with gene symbols extracted from the same GTF file
that was supplied to _featureCounts_ for quantitation:

```{r annotateSymbol_sce.filtered}
fData(sce.filtered)$gene_name <-
  gtfData$gene_name[match(rownames(sce.filtered), gtfData$gene_id)]
```

# References

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->

```{r save_sce.pass, include=FALSE}
saveRDS(sce.filtered, "rds/sce.filtered.rds")
```
