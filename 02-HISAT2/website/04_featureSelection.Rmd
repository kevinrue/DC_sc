---
title: "Feature selection"
bibliography:
  bibtex.bib
---

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scater)
library(edgeR)
library(ggplot2)
library(SummarizedExperiment)
sce.pass <- readRDS("rds/sce.pass.rds")
sce.bulk <- readRDS("rds/sce.bulk.rds")
gtfData <- readRDS("rds/gtfData.rds")
mixC <- readRDS("rds/mixC.rds")
ERCCs <- grep("^ERCC-[[:digit:]]+$", featureNames(sce.pass), value = TRUE)
MTs <- mcols(gtfData)[seqnames(gtfData) == "MT", "gene_id"]
```

# Correlation of bulks and single cell average {.tabset}

For each experimental group of single cells, let us calculate the average
expression level (`log2(counts+1)`) of each feature:

```{r}
bulkSCdata <- list()
for (groupName in levels(sce.pass$Group)){
  time <- gsub("^(.*h)_.*", "\\1", groupName)
  infection <- gsub(".*_(.*)_.*", "\\1", groupName) 
  cellIndex <- which(sce.pass$Group == groupName)
  cellAvg <- rowMeans(exprs(sce.pass[,cellIndex]))
  bulkExpr <- exprs(sce.bulk)[,which(
    sce.bulk$Time == time & sce.bulk$Infection == infection
    )]
  geneNames <- names(cellAvg)
  bulkSCdata[[groupName]] <- data.frame(
    Cells = cellAvg[geneNames], Bulk = bulkExpr, row.names = geneNames
  )
}
```

We may then display the average expression level of each gene within each
experimental group of single cells against their matched bulk sample.

Importantly, stimulated bulk samples are expected to be a mixture of
`infected` and `exposed` cells. We may therefore compare the average expression
in each subset of cells against the bulk average, to identify potential
differences:

## 2h_Mock_uninfected

```{r 2h_Mock_uninfected}
ggplot(bulkSCdata[["2h_Mock_uninfected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_Mock_uninfected

```{r 4h_Mock_uninfected}
ggplot(bulkSCdata[["4h_Mock_uninfected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_Mock_uninfected

```{r 6h_Mock_uninfected}
ggplot(bulkSCdata[["6h_Mock_uninfected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 2h_D23580_exposed

```{r 2h_D23580_exposed}
ggplot(bulkSCdata[["2h_D23580_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_D23580_exposed

```{r 4h_D23580_exposed}
ggplot(bulkSCdata[["4h_D23580_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_D23580_exposed

```{r 6h_D23580_exposed}
ggplot(bulkSCdata[["6h_D23580_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 2h_LT2_exposed

```{r 2h_LT2_exposed}
ggplot(bulkSCdata[["2h_LT2_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_LT2_exposed

```{r 4h_LT2_exposed}
ggplot(bulkSCdata[["4h_LT2_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_LT2_exposed

```{r 6h_LT2_exposed}
ggplot(bulkSCdata[["6h_LT2_exposed"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 2h_D23580_infected

```{r 2h_D23580_infected}
ggplot(bulkSCdata[["2h_D23580_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_D23580_infected

```{r 4h_D23580_infected}
ggplot(bulkSCdata[["4h_D23580_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_D23580_infected

```{r 6h_D23580_infected}
ggplot(bulkSCdata[["6h_D23580_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 2h_LT2_infected

```{r 2h_LT2_infected}
ggplot(bulkSCdata[["2h_LT2_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 4h_LT2_infected

```{r 4h_LT2_infected}
ggplot(bulkSCdata[["4h_LT2_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

## 6h_LT2_infected

```{r 6h_LT2_infected}
ggplot(bulkSCdata[["6h_LT2_infected"]]) +
  stat_bin2d(aes(Bulk, Cells), bins = 100) + guides(fill = FALSE)
```

# Overview of feature detection levels

Having selected single cells that pass all quality control criteria in the
previous sections, let us identify features that are robustly detected across
single cells in the data set.
Indeed, features detected in a small count of cells, or expressed at very
low levels carry limited information for differential expression analyses;
moreover, those features negatively affect the performance of normalisation
algorithms, due to the large number of dropout (*i.e.*, zero count) events
[@67; @Brennecke_2013].

First, let us initalise the matrix of CPM:

```{r cpm}
scater::cpm(sce.pass) <- edgeR::cpm(counts(sce.pass))
range(colSums(cpm(sce.pass)))
```

## Detection frequency and mean expression level

For this purpose, let us first calculate updated QC metrics in the subsetted
data set using once more the [scater](http://bioconductor.org/packages/scater)
`calculateQCMetrics` method:

```{r pass_calculateQCMetrics}
sce.pass <- calculateQCMetrics(
  sce.pass, feature_controls = list(ERCC = ERCCs, MT = MTs)
)
```

We may then examine for each feature the proportion of cells in which it is
detected (non-zero expression level) against its average expression level
across all cells:

```{r plotExprsFreqVsMean}
plotExprsFreqVsMean(
  sce.pass,
  feature_controls = fData(sce.pass)$is_feature_control_ERCC
)
```

## Spike-in expectations

Let us compare the expected number of spike-in molecules introduced in each
sample (calculated in this [section](00b_moleculesERCC.html)) against the
average count detected across all single cells, while indicating the identity
relationship $y = x$ as a solid black line:

```{r ERCCcorrelation, warning=FALSE, fig.height=6}
mixC$avgCount <- rowMeans(counts(sce.pass)[mixC$ID,])
names(mixC)
maxPlot <- max(mixC$avgCount, mixC$ERCCmolecules)
ggplot(mixC) + geom_point(aes(ERCCmolecules, avgCount)) +
  labs(x = "ERCC molecules injected", y = "Average count in cells passed QC") +
  geom_abline(slope = 1, intercept = 0) +
  scale_x_log10() + scale_y_log10() + coord_fixed(ratio = 1)
```

# Definition of detected feature {.tabset}

Let us examine the distribution of log-mean CPM across all genes, while
indicating an average value of **1** CPM:

```{r detectVsMean_hist}
ave.cpm <- rowMeans(scater::cpm(sce.pass))
hist(
  log10(ave.cpm), breaks = 100,
  main = "", xlab = expression(Log[10]~"average CPM", col="grey80")
)
abline(v = log10(1), col = "blue", lwd = 2, lty = 2)
```

We may compare the above figure with the a smoother representation of the
count of cells in which each feature is detected against the average
log~10~-transformed count of reads assigned to that same feature, while
marking the same cut-off threshold of an average **1** count across all cells:

```{r smoothScatter}
numcells <- nexprs(sce.pass, byrow = TRUE)
is.ercc <- fData(sce.pass)$is_feature_control_ERCC
smoothScatter(
  log10(ave.cpm), numcells, xlab=expression(Log[10]~"average CPM"),
  ylab="Number of expressing cells"
)
points(
  log10(ave.cpm[is.ercc]), numcells[is.ercc],
  col = "red", pch = 16, cex = 0.5
)
abline(v = log10(1), col = "blue", lwd = 2, lty = 2)
```

In the context of the present multifactorial experimental design, let us define
informative endogenous features as those with an average count above a
threshold of **20** counts per million (CPM) in at least **1** experimental
group of cells (`r min(table(sce.pass$Group))`-`r max(table(sce.pass$Group))`
cells per group, after exclusion of outliers).
In contrast, let us define informative spike-in features
as those with an average count greater or equal to a threhsold of **1** count.
Note that the count of cells per group was reported
[here](03_sampleQC#cellSelection)

Let us first calculate the average CPM for each gene within each experimental
group:

**Note:** Make sure to use `scater::cpm` (*not* `edge::cpm`) below, to
*access* the `cpm` matrix of the `assayData` slot; otherwise a new CPM matrix
may be inappropriately calculated.

```{r avgCPMbyGroup}
avgCPMbyGroup <- apply(scater::cpm(sce.pass), 1, function(x){
  tapply(x, sce.pass$Group, mean)})
avgCPMbyGroup <- reshape2::melt(
  avgCPMbyGroup, varnames = c("Group", "Feature"), value.name = "AvgCPM")
```

The following figure display the distribution of average log~10~(CPM)
within each experimental group of single cells:

```{r density_avgCPM}
ggplot(avgCPMbyGroup) + geom_density(aes(log10(AvgCPM))) +
  facet_wrap(~ Group)
```

Let us now obtain---for each feature---the proportion of cells within each
experimental group of cells that display an expression level above **10** CPM:

```{r propOver20byGroup}
propOver20byGroup <- apply(scater::cpm(sce.pass), 1, function(x){
  tapply(x, sce.pass$Group, function(x){sum(x > 10) / length(x)})
})
propOver20byGroup <- reshape2::melt(
  propOver20byGroup, varnames = c("Group", "Feature"), value.name = "Proportion")
```

# Selection of detected features {#selectFeatures}

Following the above observations, let us retain for further analysis:

* endogenous features detected above **10** CPM in at least **25%** of at least
  **1** experimental group of cells
* ERCC spike-in features detected at an average level greater than **1** count
  across all cells:

```{r}
detectedFeatures <- names(which(tapply(
  propOver20byGroup$Proportion, propOver20byGroup$Feature,
  function(x){sum(x > 0.25) > 0})))
```

```{r detectedFeatures}
keepEndogenous <- (featureNames(sce.pass) %in% detectedFeatures) &
  (!isSpike(sce.pass))
keepSpike <- (rowMeans(counts(sce.pass)) > 1) & (isSpike(sce.pass))
table(keepEndogenous); table(keepSpike)
```

```{r sce.filtered}
sce.filtered <- sce.pass[keepEndogenous | keepSpike,]
dim(sce.filtered)
```

# References

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->

```{r save_sce.pass, include=FALSE}
saveRDS(sce.filtered, "rds/sce.filtered.rds")
```
