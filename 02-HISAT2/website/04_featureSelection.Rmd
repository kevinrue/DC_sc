---
title: "Feature selection"
bibliography:
  bibtex.bib
---

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scater)
library(edgeR)
library(ggplot2)
library(SummarizedExperiment)
sce.pass <- readRDS("rds/sce.pass.rds")
gtfData <- readRDS("rds/gtfData.rds")
mixC <- readRDS("rds/mixC.rds")
ERCCs <- grep("^ERCC-[[:digit:]]+$", featureNames(sce.pass), value = TRUE)
MTs <- mcols(gtfData)[seqnames(gtfData) == "MT", "gene_id"]
```

# Overview of feature detection levels

Having selected single cells that pass all quality control criteria in the
previous sections, let us identify features that are robustly detected across
single cells in the data set.
Indeed, features detected in a small count of cells, or expressed at very
low levels carry limited information for differential expression analyses;
moreover, those features negatively affect the performance of normalisation
algorithms, due to the large number of dropout (*i.e.*, zero count) events
[@67; @Brennecke_2013].

First, let us initalise the matrix of CPM:

```{r cpm}
scater::cpm(sce.pass) <- edgeR::cpm(counts(sce.pass))
range(colSums(cpm(sce.pass)))
```

## Detection frequency and mean expression level

For this purpose, let us first calculate updated QC metrics in the subsetted
data set using once more the [scater](http://bioconductor.org/packages/scater)
`calculateQCMetrics` method:

```{r pass_calculateQCMetrics}
sce.pass <- calculateQCMetrics(
  sce.pass, feature_controls = list(ERCC = ERCCs, MT = MTs)
)
```

We may then examine for each feature the proportion of cells in which it is
detected (non-zero expression level) against its average expression level
across all cells:

```{r plotExprsFreqVsMean}
plotExprsFreqVsMean(
  sce.pass,
  feature_controls = fData(sce.pass)$is_feature_control_ERCC
)
```

## Spike-in expectations

Let us compare the expected number of spike-in molecules introduced in each
sample (calculated in this [section](00b_moleculesERCC.html)), against the
average count detected across all single cells:

```{r ERCCcorrelation, warning=FALSE}
mixC$avgCount <- rowMeans(counts(sce.pass)[mixC$ID,])
names(mixC)
maxPlot <- max(mixC$avgCount, mixC$ERCCmolecules)
ggplot(mixC) + geom_point(aes(ERCCmolecules, avgCount)) +
  labs(x = "ERCC molecules injected", y = "Average count in cells passed QC") +
  scale_x_log10() + scale_y_log10() + coord_fixed(ratio = 1)
```

# Definition of detected feature {.tabset}

Let us examine the distribution of log-mean CPM across all genes, while
indicating an average value of 10 CPM:

```{r detectVsMean_hist}
ave.cpm <- rowMeans(scater::cpm(sce.pass))
hist(
  log10(ave.cpm), breaks = 100,
  main = "", xlab = expression(Log[10]~"average CPM", col="grey80")
)
abline(v = log10(1), col = "blue", lwd = 2, lty = 2)
```

We may compare the above figure with the a smoother representation of the
count of cells in which each feature is detected against the average
log~10~-transformed count of reads assigned to that same feature, while
marking the same cut-off threshold of an average $1$ count across all cells:

```{r smoothScatter}
numcells <- nexprs(sce.pass, byrow = TRUE)
is.ercc <- fData(sce.pass)$is_feature_control_ERCC
smoothScatter(
  log10(ave.cpm), numcells, xlab=expression(Log[10]~"average CPM"),
  ylab="Number of expressing cells"
)
points(
  log10(ave.cpm[is.ercc]), numcells[is.ercc],
  col = "red", pch = 16, cex = 0.5
)
abline(v = log10(1), col = "blue", lwd = 2, lty = 2)
```

In the context of the present multifactorial experimental design,
let us define informative endogenous features as those with an average count
above a threshold of 20 counts per million (CPM) in at least one experimental
group of cells (`r min(table(sce.pass$Group))`-`r max(table(sce.pass$Group))`
cells per group). In contrast, let us define informative spike-in features
as those with an average count greater or equal to a threhsold of 2 counts.
Note that the count of cells per group was reported
[here](03_sampleQC#cellSelection)

Let us first calculate the average CPM for each gene within each experimental
group:

**Note:** Make sure to use `scater::cpm` (*not* `edge::cpm`) below, to
*access* the `cpm` matrix of the `assayData` slot; otherwise a new CPM matrix
may be inappropriately calculated.

```{r avgCPMbyGroup}
avgCPMbyGroup <- apply(scater::cpm(sce.pass), 1, function(x){
  tapply(x, sce.pass$Group, mean)
})
avgCPMbyGroup <- reshape2::melt(
  avgCPMbyGroup, varnames = c("Group", "Feature"), value.name = "AvgCPM")
```

Let us examine the proportion of gene features expressed at various levels in 
each experimental groups:

```{r}
zeroCounts <- data.frame(
  Group = levels(avgCPMbyGroup$Group),
  y = 1E-2,
  Count = with(avgCPMbyGroup, tapply(AvgCPM, Group, function(x){sum(x>0)}))
)
avgCPMbyGroup$Time = gsub("^(.*h)_.*", "\\1", avgCPMbyGroup$Group)
avgCPMbyGroup$Infection = factor(
  gsub(".*_(.*)_.*", "\\1", avgCPMbyGroup$Group), c("D23580","LT2","Mock"))
avgCPMbyGroup$Status = factor(
  gsub(".*_(.*)$", "\\1", avgCPMbyGroup$Group), c("infected","exposed","uninfected"))
```

The figure below indicates the 3 quartiles for
each experimental group, *after removal of features with zero counts
(indicated in the bottom label)*.
For instance, generally ~30% of "detectable" features are
found below 1 CPM (across all cells that passed QC filtering),
while ~50-60% of features are detected above 10 CPM:

```{r violinAvgCPMbyGroup}
ggplot(avgCPMbyGroup, aes(Group, AvgCPM)) +
  geom_violin(
    aes(colour = Infection, fill = Status), alpha = 0.4,
    draw_quantiles = seq(0.25, 0.75, 0.25)) +
  geom_label(aes(Group, y, label = Count), data = zeroCounts, size = 2) +
  scale_y_log10(limits = c(1E-2, 1E5)) +
  theme(
    axis.text.x = element_text(angle = 90), panel.grid.major.x = element_blank()
  )
```

Let us now count and display for each feature the number of experimental groups
with an average CPM above various threshold:

```{r}
cutoffs <- c(10,20,50,100)
groupsAboveCPM <- as.data.frame(sapply(
  cutoffs,
  function(cutoff){
    with(avgCPMbyGroup, tapply(AvgCPM, Feature, function(x){sum(x > cutoff)}))
  }
))
colnames(groupsAboveCPM) <- paste0("cpm", cutoffs)
axisLabels <- labs(x="Feature index",y="Count of groups above CPM cutoff")
```

## 10 CPM

```{r groupAbove10cpm}
ggplot(groupsAboveCPM) +
  geom_line(aes(seq_len(nrow(groupsAboveCPM)), sort(cpm10, decreasing=TRUE))) +
  axisLabels
```

`r sum(groupsAboveCPM$cpm10 >= 1)` features have an average CPM above 10 in at
least one experimental group.

## 20 CPM

```{r groupAbove20cpm}
ggplot(groupsAboveCPM) +
  geom_line(aes(seq_len(nrow(groupsAboveCPM)), sort(cpm20, decreasing=TRUE))) +
  axisLabels
```

`r sum(groupsAboveCPM$cpm20 >= 1)` features have an average CPM above 20 in at
least one experimental group.

## 50 CPM

```{r groupAbove50cpm}
ggplot(groupsAboveCPM) +
  geom_line(aes(seq_len(nrow(groupsAboveCPM)), sort(cpm50, decreasing=TRUE))) +
  axisLabels
```

`r sum(groupsAboveCPM$cpm50 >= 1)` features have an average CPM above 50 in at
least one experimental group.

## 100 CPM

```{r groupAbove100cpm}
ggplot(groupsAboveCPM) +
  geom_line(aes(seq_len(nrow(groupsAboveCPM)), sort(cpm100, decreasing=TRUE))) +
  axisLabels
```

`r sum(groupsAboveCPM$cpm100 >= 1)` features have an average CPM above 100 in at
least one experimental group.

# Selection of detected features {#selectFeatures}

Following the above observations, let us retain for further analysis:

* endogenous features detected at an average level greater than 20 CPM in at
  least one experimental group,
* ERCC spike-in features detected at an average level of at least 2 counts
  across all cells:

```{r ave.counts}
keep <- groupsAboveCPM[,"cpm20"] >= 1
ERCC_idx <- fData(sce.pass)[,"is_feature_control_ERCC"]
keep[ERCC_idx] <- rowMeans(counts(sce.pass)[ERCC_idx,]) > 2
sce.filtered <- sce.pass[keep,]
dim(sce.filtered)
```

To facilitate later interpretation, let us annotate endogenous feature
identifiers in the `SCESet` with gene symbols extracted from the same GTF file
that was supplied to _featureCounts_ for quantitation:

```{r annotateSymbol_sce.filtered}
fData(sce.filtered)$gene_name <-
  gtfData$gene_name[match(rownames(sce.filtered), gtfData$gene_id)]
```

# References

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->

```{r save_sce.pass, include=FALSE}
saveRDS(sce.filtered, "rds/sce.filtered.rds")
```
