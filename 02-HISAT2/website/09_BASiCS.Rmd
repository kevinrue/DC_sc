---
title: "Differential expression using BASiCS"
bibliography:
  bibtex.bib
---

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scran)
library(scater)
library(BASiCS)
library(ggplot2)
sce.norm <- readRDS("rds/sce.norm.rds")
mixC <- readRDS("rds/mixC.rds")
EnsDb.Hsapiens.v79 <- EnsDb.Hsapiens.v79::EnsDb.Hsapiens.v79
```

# Data pre-processing

## Input data

For this analysis we use:

* the matrix of expression *counts*
* single cells that passed all quality control filters (see this earlier
  [section](03_sampleQC.html#cellSelection))
* features with an average count equal or higher than $1$ (see this earlier
  [section](04_featureSelection#selectFeatures))

**Note:** this contrasts with the stringent condition of â‰¥20 RPM on average
across all cells, demonstrated in [@BASiCS2016DE]. However, feature
selection is highly dependent on the nature of the experimental design.

As a result, the input data contains `r nrow(sce.norm)` features and
`r ncol(sce.norm)` cells.

# BASiCS analysis

## The input dataset

### Spike-in genes information

In subsequent steps of the analysis, technical spike-in features are identified using the `scater::isSpike` method:

```{r isSpike, include=FALSE}
table(isSpike(sce.norm))
```

This confirms that `r sum(isSpike(sce.norm))` ERCC spike-in features are left in
the filtered dataset.

### Creating the input objects

To use BASiCS, we need to create a `BASiCS_Data` object containing the
expression counts, a vector of logical spike-in gene indicators
and the input number of mRNA molecules for each spike-in gene.

```{r Data.input, results='hide', message=FALSE, warning=FALSE}
Data.input <- list()
ERCCnames <- rownames(sce.norm)[isSpike(sce.norm)]
for (groupName in unique(sce.norm$Group)){
  cellIndex <- which(sce.norm$Group == groupName)
  Data.input[[groupName]] <- newBASiCS_Data(
    Counts = counts(sce.norm)[,cellIndex],
    Tech = isSpike(sce.norm),
    SpikeInfo = mixC[ERCCnames, c("ID","ERCCmolecules")],
    BatchInfo = sce.norm$Plate[cellIndex])
}
```

**Note:**
Due to the nature of the feature selection filters, in the above code chunk
the `newBASiCS_Data` method prints the following message for all 15 groups
of cells:

```{r warning_newData, echo=FALSE}
warning("Some genes have zero counts across all cells. Unless running a differential expression analysis, please remove those genes. Otherwise, the BASiCS_Data object is still a valid object. However, due to the lack of counts, posterior estimates for mu[i] and delta[i] associated to those genes will be driven by the prior. In such case, you must specify `PriorDelta = 'log-normal' in BASiCS_MCMC function.")
```

## Fitting the BASiCS model (for differential expression)

To run the MCMC algorithm for differential expression,
we use the function `BASiCS_MCMC`, following the recommendation prompted
by the `newBASiCS_Data` function:

* `PriorDelta` argument set to `"log-normal"`
* due to the presence, within each experimental group of cells, of genes with
  zero counts across all cells within that group, only use those `BASiCS_Data`
  objects for differential expression analysis, *not*
  differential over-dispersion

```{r BASiCS_MCMC, results='hide', message=FALSE, eval=FALSE}
MCMC_Output_DE <- list()
N <- 20E3; Thin <- 10; Burn <- 10E3; chains.path <- "BASiCS"
for (groupName in names(Data.input)){
  MCMC_Output_DE[[groupName]] <- BASiCS_MCMC(
    Data.input[[groupName]], N = N, Thin = Thin, Burn = Burn,
    PrintProgress = TRUE, StoreChains = TRUE, PriorDelta = 'log-normal',
    StoreDir = chains.path, RunName = paste(groupName, N, sep= "_"))
}
```

```{r saveRDS, eval=FALSE}
saveRDS(MCMC_Output_DE, "rds/MCMC_Output.rds")
```

Confirm that all groups of cells were run:

```{r deleteMe}
names(MCMC_Output_DE)
```

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->
