---
title: "Differential expression using BASiCS"
bibliography:
  bibtex.bib
---

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scran)
library(scater)
library(BASiCS)
library(ggplot2)
sce.norm <- readRDS("rds/sce.norm.rds")
mixC <- readRDS("rds/mixC.rds")
EnsDb.Hsapiens.v79 <- EnsDb.Hsapiens.v79::EnsDb.Hsapiens.v79
```

# Data pre-processing

## Input data

For this analysis we use:

* the matrix of expression *counts*
* single cells that passed all quality control filters (see this earlier
  [section](03_sampleQC.html#cellSelection))
* features with an average count equal or higher than $1$ (see this earlier
  [section](04_featureSelection#selectFeatures))

```{r scePassCounts, eval=FALSE}
dim(counts(sce.norm))
```

**Note:** this contrasts with the stringent condition of â‰¥20 RPM on average
across all cells, demonstrated in [@BASiCS2016DE].

As a result, the input data contains `r nrow(sce.norm)` features and
`r ncol(sce.norm)` cells.

# BASiCS analysis

## The input dataset

### Spike-in genes information

In subsequent steps of the analysis, technical spike-in features are identified
as follows:

```{r, results='hide'}
isSpike(sce.norm)
```

This confirms that `r sum(isSpike(sce.norm))` ERCC spike-in features are left
in the filtered dataset:

```{r}
table(isSpike(sce.norm))
```

### Creating the input objects

To use BASiCS, we need to create a `BASiCSDV_Data` object containing the
expression counts, a vector of logical spike-in gene indicators
and the input number of mRNA molecules for each spike-in gene.

```{r, warning=FALSE, results='hide', message=FALSE}
Data.input <- list()
ERCCnames <- rownames(sce.norm)[isSpike(sce.norm)]
for (groupName in unique(sce.norm$Group)){
  cellIndex <- which(sce.norm$Group == groupName)
  Data.input[[groupName]] <- newBASiCS_Data(
    Counts = counts(sce.norm)[,cellIndex],
    Tech = isSpike(sce.norm),
    SpikeInfo = mixC[ERCCnames, c("ID","ERCCmolecules")],
    BatchInfo = sce.norm$Plate[cellIndex])
}
```

## Fitting the BASiCS model

To run the MCMC algorithm, we use the function `BASiCS_MCMC`:

**Note:** The following blocks of code currently crash after completion
of the MCMC algorithm, with the following error message:

```{r, echo=FALSE}
message(" Show Traceback
Error in dimnames(x) <- dn : length of 'dimnames' [2] not equal to array extent")
```


```{r eval=FALSE}
for (groupName in names(Data.input)){
  print(length(Data.input[[groupName]]@GeneNames))
  print(length(Data.input[[groupName]]@BatchInfo))
  print(table(Data.input[[groupName]]@Tech))
}
```


```{r, eval=FALSE}
N <- 2E2; Thin <- 10; Burn <- 1E2; chains.path <- "BASiCS"
MCMC_Output.G1 <- BASiCS_MCMC(
  Data.input[["2h_D23580_exposed"]], N = N, Thin = Thin, Burn = Burn,
  PrintProgress = TRUE, StoreChains = TRUE,
  StoreDir = chains.path, RunName = paste(groupName, N, sep= "_"),
  PriorDelta = 'log-normal')
```

```{r, eval=FALSE}
MCMC_Output <- list()
N <- 20E3; Thin <- 10; Burn <- 10E3; chains.path <- "BASiCS"
for (groupName in names(Data.input)){
  MCMC_Output[[groupName]] <- BASiCS_MCMC(
    Data.input[[groupName]], N = N, Thin = Thin, Burn = Burn,
    PrintProgress = TRUE, StoreChains = TRUE,
    StoreDir = chains.path, RunName = paste(groupName, N, sep= "_"),
    PriorDelta = 'log-normal')
}
```

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->
