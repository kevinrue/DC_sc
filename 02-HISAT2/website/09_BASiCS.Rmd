---
title: "Differential expression using BASiCS"
bibliography:
  bibtex.bib
---

```{r checkPkgs, child="_checkLibraries.Rmd", include=FALSE}
```

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scran)
library(scater)
library(BASiCS)
library(data.table) 
library(EnsDb.Hsapiens.v79) 
library(ggplot2)
sce.norm <- readRDS("rds/sce.norm.rds")
mixC <- readRDS("rds/mixC.rds")
```

# Data pre-processing

## Input data

For this analysis we use:
* the matrix of expression *counts*
* single cells that passed all quality control filters (see this earlier
  [section](03_sampleQC.html#cellSelection))
* features with an average count equal or higher than $1$ (see this earlier
  [section](04_featureSelection#selectFeatures))

```{r scePassCounts, results='hide'}
counts(sce.norm)
```

**Note:** this contrasts with the stringent condition of â‰¥20 RPM on average
across all cells, demonstrated in [@BASiCS2016DE].

As a result, the input data contains `r nrow(sce.norm)` features and
`r ncol(sce.norm)` cells.

# BASiCS analysis

## The input dataset

### Spike-in genes information

In subsequent steps of the analysis, technical spike-in features are identified
as follows:

```{r, results='hide'}
isSpike(sce.norm)
```

This confirms that `r sum(isSpike(sce.norm))` ERCC spike-in features are left
in the filtered dataset:

```{r}
table(isSpike(sce.norm))
```

### Creating the input objects

To use BASiCS, we need to create a `BASiCSDV_Data` object containing the
expression counts, a vector of logical spike-in gene indicators
and the input number of mRNA molecules for each spike-in gene.

```{r, results='hide'}
Data.input <- list()
ERCCnames <- rownames(sce.norm)[isSpike(sce.norm)]
for (groupName in unique(sce.norm$Group)){
  cellIndex <- which(sce.norm$Group == groupName)
  Data.input[[groupName]] <- newBASiCS_Data(
    Counts = counts(sce.norm)[,cellIndex],
    Tech = isSpike(sce.norm),
    SpikeInfo = mixC[ERCCnames, c("ID","ERCCmolecules")],
    BatchInfo = sce.norm$Plate[cellIndex])
}
```

## Fitting the BASiCS model

To run the MCMC algorithm, we use the function `BASiCS_MCMC`:

**Note:** The following blocks of code currently crash after completion
of the MCMC algorithm, with the following error message:

```{r, echo=FALSE}
message(" Show Traceback
Error in dimnames(x) <- dn : length of 'dimnames' [2] not equal to array extent")
```


```{r, eval=FALSE}
N <- 2E3; Thin <- 10; Burn <- 1E3; chains.path <- "BASiCS"
MCMC_Output.G1 <- BASiCS_MCMC(
  Data.input[["2h_D23580_exposed"]], N = N, Thin = Thin, Burn = Burn,
  PrintProgress = TRUE, StoreChains = TRUE,
  StoreDir = chains.path, RunName = paste(groupName, N, sep= "_"),
  PriorDelta = 'log-normal')
```

```{r, eval=FALSE}
MCMC_Output <- list()
N <- 20E3; Thin <- 10; Burn <- 10E3; chains.path <- "BASiCS"
for (groupName in names(Data.input)){
  MCMC_Output[[groupName]] <- BASiCS_MCMC(
    Data.input[[groupName]], N = N, Thin = Thin, Burn = Burn,
    PrintProgress = TRUE, StoreChains = TRUE,
    StoreDir = chains.path, RunName = paste(groupName, N, sep= "_"),
    PriorDelta = 'log-normal')
}
```


<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->
