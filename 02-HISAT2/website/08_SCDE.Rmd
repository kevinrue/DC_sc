---
title: "Differential expression"
bibliography:
  bibtex.bib
---

```{r checkPkgs, child="_checkLibraries.Rmd", include=FALSE}
```

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scater)
library(scran)
library(scde)
library(dplyr)
library(EnsDb.Hsapiens.v79)
sce.norm <- readRDS("rds/sce.norm.rds")
```

# Prepare data

The analysis starts with a matrix of read counts,
filtered based on gene and cell requirements.
In this case, let us use the raw numbers of reads mapped to each endogenous
feature, recast as `integer` type:

```{r cleanCounts}
cd <- clean.counts(
  counts(sce.norm)[!isSpike(sce.norm),],
  min.lib.size = 1000, min.reads = 1, min.detected = 1
)
cd <- apply(cd, 2, function(x){storage.mode(x) <- 'integer'; x})
dim(cd)
```

Let us also define a factor that separate cells from each experimental group:

```{r sg}
sg <- as.factor(
  with(pData(sce.norm), paste(Time, Infection, Status, sep = "_"))
)
names(sg) <- colnames(sce.norm)  
```

# Fitting error models

As a next step we fit the error models on which all subsequent calculations
will rely. The fitting process relies on a subset of robust genes that are
detected in multiple cross-cell comparisons. Here we supply the `groups=sg`
argument, so that the error models for each experimental group of cells
are fit independently
(using two different sets of "robust" genes). If the groups argument is
omitted, the models will be fit using a common set.

**Note:** this step takes a considerable amount of time, even when multiple
cores are used (\approx 1h using 4 cores to fit error models to each of the
``r length(levels(sg))``).
For this purpose, the chunk of code below is not executed during
automated compilation; instead it is manually recomputed as necessary.

```{r oifm, message=FALSE, eval=FALSE}
o.ifm <- scde.error.models(
  counts = cd, groups = sg, n.cores = 4, threshold.segmentation = TRUE,
  save.crossfit.plots = FALSE, save.model.plots = FALSE, verbose = 1
)
saveRDS(o.ifm, "rds/o.ifm.rds")
```

During automated compilation, manually computed error models are imported
to save execution time:

```{r readOIfm}
o.ifm <- readRDS("rds/o.ifm.rds")
```

The `o.ifm` is a `data.frame` with error model coefficients for each cell.

```{r oIfmTrim}
o.ifm.trim <- apply(o.ifm, 2, round, digits = 2)
DT::datatable(
  o.ifm.trim,
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

Here, `corr.a` and `corr.b` are slope and intercept of the correlated component
fit, `conc.*` refer to the concomitant fit, `corr.theta` is the NB
over-dispersion, and `fail.r` is the background Poisson rate (fixed).

Particularly poor cells may result in abnormal fits, most commonly showing
negative corr.a, and should be removed.

```{r validCells}
valid.cells <- o.ifm$corr.a > 0
table(valid.cells)
```

```{r oIfmValid}
o.ifm <- o.ifm[valid.cells, ]
```

Here, all the fits were valid; the above chunk of code does not actually do
anything to the data.

Finally, we need to define an expression magnitude prior for the genes.
Its main function, however, is to define a grid of expression magnitude values
on which the numerical calculations will be carried out.

```{r oPrior}
o.prior <- scde.expression.prior(
  models = o.ifm, counts = cd, length.out = 400, show.plot = TRUE
)
```

Here we used a grid of `400` points, and let the maximum expression magnitude
be determined by the default `0.999` quantile
(use `max.value` parameter to specify the maximum expression magnitude
explicitly --- on log~10~ scale).

# Testing for differential expression {.tabset}

To test for differential expression:

* first, we match the order of single cells in the fitted error models to the
  order of the single cells in the original count matrix;
* we use the above mapping to identify the experimental group and batch of each
  single cell in the order of the fitted error models,
* we define for each comparison a factor in the form of a vector that specifies
  which two groups of single cells are to be compared; the factor elements
  correspond to the rows of the fitted error models, and contain `NA` values
  for single cells that are not included in either group,
* we let [scde](http://bioconductor.org/packages/scde) estimate differential
  expression between the two groups of single cells, after batch correction;
  *Note that results without batch corrections are also available in this way*,
* we sort genes by decreasing absolute (uncorrected) Z-score of expression
  difference; this order highlights the most significantly DE genes at the top
  of the table, regardless of their direction of differential expression,
* we annotate genes with their gene name (at this stage, genes were only
  identified by their Ensembl gene identifier).
* we store in two separate `list` objects *only* genes that have a
  expression difference Z-score corrected for multiple hypothesis
  different than zero (*i.e.* significantly DE):
  + without batch correction
  + with batch correction applied by plate processed:

```{r scdeExprDiff, eval=FALSE, results='hold'}
newOrder <- match(rownames(o.ifm), colnames(sce.norm))
sg.all <- sg[newOrder]
batch <- sce.norm$Plate[newOrder]
DE.res.raw <- list()
DE.res.batch <- list()
for (time in levels(sce.norm$Time)){
  for (infection in levels(sce.norm$Infection)[-1]){
    for (status in levels(sce.norm$Status)[-1]){
      sg.ref <- paste(
        time,
        levels(sce.norm$Infection)[1],
        levels(sce.norm$Status)[1],
        sep = "_"
      )
      sg.tar <- paste(time, infection, status, sep = "_")
      contrast <- sprintf("%s - %s", sg.tar, sg.ref)
      message(contrast)
      groups <- rep(NA, length(sg.all))
      names(groups) <- names(sg.all)
      groups[which(sg.all == sg.ref)] <- sg.ref
      groups[which(sg.all == sg.tar)] <- sg.tar
      groups <- factor(groups, c(sg.tar, sg.ref)) # target - reference
      scde.res <- scde.expression.difference(
        o.ifm, cd, o.prior,
        groups = groups,
        batch = batch,
        n.randomizations = 10,
        n.cores  =  1, verbose  =  1
      )
      de.raw <- scde.res$results
      de.batch <- scde.res$batch.adjusted
      de.raw <- de.raw[order(abs(de.raw$Z), decreasing = TRUE),]
      de.batch <- de.batch[order(abs(de.batch$Z), decreasing = TRUE),]
      de.raw <- cbind(
        GENENAME=mapIds(EnsDb.Hsapiens.v79,rownames(de.raw),"GENENAME","GENEID"),
        de.raw
      )
      de.batch <- cbind(
        GENENAME=mapIds(EnsDb.Hsapiens.v79,rownames(de.batch),"GENENAME","GENEID"),
        de.batch
      )
      DE.res.raw[[sg.tar]] <- de.res[de.raw$cZ != 0,]
      DE.res.batch[[sg.tar]] <- de.batch[de.batch$cZ != 0,]
    }
  }
}
```

```{r saveRdsDE, include=FALSE}
saveRDS(DE.res.raw, "rds/DE.res.raw.rds")
saveRDS(DE.res.batch, "rds/DE.res.batch.rds")
```

During automated compilation, manually computed differential expression results
are imported to save execution time:

```{r readRdsDe}
DE.res.raw <- readRDS("rds/DE.res.raw.rds")
DE.res.batch <- readRDS("rds/DE.res.batch.rds")
```

# Count of of DE genes

Let us display the count of differentially expressed genes:

* Without batch correction (`Raw`)
* With batch correction applied by plate processed (`Batch`). *Note that
  all samples of any of the `4` plates were processed on the same of the `2`
  sequencing lanes; as a result, accounting for a plate batch implicitely
  accounts for a lane batch.*

```{r countDE}
DT::datatable(data.frame(
  "Raw" = sapply(names(DE.res.raw), function(n){nrow(DE.res.raw[[n]])}),
  "Batch" = sapply(names(DE.res.batch), function(n){nrow(DE.res.batch[[n]])})
  ),
  options = list(pageLength = 12)
)
```

# Tables of differentially expressed genes {.tabset}

Let us display the tables of DE genes for the various contrasts calculated
above.

## 2h_D23580_exposed

```{r 2h_D23580_exposed}
DT::datatable(
  DE.res.batch[["2h_D23580_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 2h_D23580_infected

```{r 2h_D23580_infected}
DT::datatable(
  DE.res.batch[["2h_D23580_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 2h_LT2_exposed

```{r 2h_LT2_exposed}
DT::datatable(
  DE.res.batch[["2h_LT2_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 2h_LT2_infected

```{r 2h_LT2_infected}
DT::datatable(
  DE.res.batch[["2h_LT2_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 4h_D23580_exposed

```{r 4h_D23580_exposed}
DT::datatable(
  DE.res.batch[["4h_D23580_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 4h_D23580_infected

```{r 4h_D23580_infected}
DT::datatable(
  DE.res.batch[["4h_D23580_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 4h_LT2_exposed

```{r 4h_LT2_exposed}
DT::datatable(
  DE.res.batch[["4h_LT2_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 4h_LT2_infected

```{r 4h_LT2_infected}
DT::datatable(
  DE.res.batch[["4h_LT2_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 6h_D23580_exposed

```{r 6h_D23580_exposed}
DT::datatable(
  DE.res.batch[["6h_D23580_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 6h_D23580_infected

```{r 6h_D23580_infected}
DT::datatable(
  DE.res.batch[["6h_D23580_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 6h_LT2_exposed

```{r 6h_LT2_exposed}
DT::datatable(
  DE.res.batch[["6h_LT2_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 6h_LT2_infected

```{r 6h_LT2_infected}
DT::datatable(
  DE.res.batch[["6h_LT2_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->
