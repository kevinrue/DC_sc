---
title: "Differential expression"
bibliography:
  bibtex.bib
---

```{r checkPkgs, child="_checkLibraries.Rmd", include=FALSE}
```

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scater)
library(scran)
library(scde)
library(dplyr)
library(EnsDb.Hsapiens.v79)
sce.norm <- readRDS("rds/sce.norm.rds")
```

# Prepare data

The analysis starts with a matrix of read counts,
filtered based on gene and cell requirements.
In this case, let us use the raw numbers of reads mapped to each endogenous
feature, recast as `integer` type:

```{r cleanCounts}
cd <- clean.counts(
  counts(sce.norm)[!isSpike(sce.norm),],
  min.lib.size = 1000, min.reads = 1, min.detected = 1
)
cd <- apply(cd, 2, function(x){storage.mode(x) <- 'integer'; x})
dim(cd)
```

Let us also define a factor that separate cells from each experimental group:

```{r sg}
sg <- as.factor(
  with(pData(sce.norm), paste(Time, Infection, Status, sep = "_"))
)
names(sg) <- colnames(sce.norm)  
```

# Fitting error models

As a next step we fit the error models on which all subsequent calculations
will rely. The fitting process relies on a subset of robust genes that are
detected in multiple cross-cell comparisons. Here we supply the `groups=sg`
argument, so that the error models for each experimental group of cells
are fit independently
(using two different sets of "robust" genes). If the groups argument is
omitted, the models will be fit using a common set.

**Note:** this step takes a considerable amount of time, even when multiple
cores are used (\approx 1h using 4 cores to fit error models to each of the
``r length(levels(sg))``).
For this purpose, the chunk of code below is not executed during
automated compilation; instead it is manually recomputed as necessary.

```{r oifm, message=FALSE, eval=FALSE}
o.ifm <- scde.error.models(
  counts = cd, groups = sg, n.cores = 4, threshold.segmentation = TRUE,
  save.crossfit.plots = FALSE, save.model.plots = FALSE, verbose = 1
)
saveRDS(o.ifm, "rds/o.ifm.rds")
```

\fixme{
Next run, save plots (TRUE).
}

During automated compilation, manually computed error models are imported
to save execution time:

```{r readOIfm}
o.ifm <- readRDS("rds/o.ifm.rds")
```

The `o.ifm` is a `data.frame` with error model coefficients for each cell.

```{r oIfmTrim}
o.ifm.trim <- apply(o.ifm, 2, round, digits = 2)
DT::datatable(
  o.ifm.trim,
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

Here, `corr.a` and `corr.b` are slope and intercept of the correlated component
fit, `conc.*` refer to the concomitant fit, `corr.theta` is the NB
over-dispersion, and `fail.r` is the background Poisson rate (fixed).

Particularly poor cells may result in abnormal fits, most commonly showing
negative corr.a, and should be removed.

```{r validCells}
valid.cells <- o.ifm$corr.a > 0
table(valid.cells)
```

```{r oIfmValid}
o.ifm <- o.ifm[valid.cells, ]
```

Here, all the fits were valid.

Finally, we need to define an expression magnitude prior for the genes.
Its main function, however, is to define a grid of expression magnitude values
on which the numerical calculations will be carried out.

```{r oPrior}
o.prior <- scde.expression.prior(
  models = o.ifm, counts = cd, length.out = 400, show.plot = TRUE
)
```

Here we used a grid of `400` points, and let the maximum expression magnitude
be determined by the default `0.999` quantile
(use `max.value` parameter to specify the maximum expression magnitude
explicitly --- on log~10~ scale).

# Testing for differential expression {.tabset}

To test for differential expression, we first define for each comparison a
factor that specifies which two groups of cells are to be compared.
The factor elements correspond to the rows of the matrix of counts (`cd`),
and can contain `NA` values
(*i.e.*, cells that won't be included in either group).

Let us start at the `2h` time point, when the differences between cells
stimulated with bacteria and uninfected are expected to be the most marked:

```{r scdeExprDiff, eval=FALSE}
newOrder <- match(rownames(o.ifm), colnames(sce.norm))
sg.all <- sg[newOrder]
batch <- sce.norm$Plate[newOrder]
DE.res.raw <- list()
DE.res.batch <- list()
for (time in levels(sce.norm$Time)){
  for (infection in levels(sce.norm$Infection)[-1]){
    for (status in levels(sce.norm$Status)[-1]){
      sg.ref <- paste(
        time,
        levels(sce.norm$Infection)[1],
        levels(sce.norm$Status)[1],
        sep = "_"
      )
      sg.tar <- paste(time, infection, status, sep = "_")
      contrast <- sprintf("%s-%s", sg.tar, sg.ref)
      message(contrast)
      groups <- rep(NA, length(sg.all))
      names(groups) <- names(sg.all)
      groups[which(sg.all == sg.ref)] <- sg.ref
      groups[which(sg.all == sg.tar)] <- sg.tar
      groups <- factor(groups, c(sg.tar, sg.ref)) # target - reference
      scde.res <- scde.expression.difference(
        o.ifm, cd, o.prior,
        groups = groups,
        batch = batch,
        n.randomizations = 10,
        n.cores  =  1, verbose  =  1
      )
      de.res <- scde.res$results
      de.raw <- de.res[order(de.res$Z, decreasing = TRUE),]
      de.batch <- scde.res$batch.adjusted
      de.batch <- de.batch[order(de.batch$Z, decreasing = TRUE),]
      de.raw <- cbind(
        GENENAME=mapIds(EnsDb.Hsapiens.v79,rownames(de.raw),"GENENAME","GENEID"),
        de.raw
      )
      de.batch <- cbind(
        GENENAME=mapIds(EnsDb.Hsapiens.v79,rownames(de.batch),"GENENAME","GENEID"),
        de.batch
      )
      DE.res.raw[[sg.tar]] <- de.res[de.raw$cZ != 0,]
      DE.res.batch[[sg.tar]] <- de.batch[de.batch$cZ != 0,]
    }
  }
}
```

```{r saveRdsDE}
saveRDS(DE.res.raw, "rds/DE.res.raw.rds")
saveRDS(DE.res.batch, "rds/DE.res.batch.rds")
```

During automated compilation, manually computed differential expression results
are imported to save execution time:

```{r readRdsDe}
DE.res.raw <- readRDS("rds/DE.res.raw.rds")
DE.res.batch <- readRDS("rds/DE.res.batch.rds")
```

```{r numDeRaw}
for (n in names(DE.res.raw)){
  message(sprintf("%s\t%i genes", n, nrow(DE.res.raw[[n]])))
}
```

```{r numDeBatch}
for (n in names(DE.res.batch)){
  message(sprintf("%s\t%i genes", n, nrow(DE.res.batch[[n]])))
}
```

## 2h_D23580_exposed

```{r 2h_D23580_exposed}
DT::datatable(
  DE.res.batch[["2h_D23580_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 2h_D23580_infected

```{r 2h_D23580_infected}
DT::datatable(
  DE.res.batch[["2h_D23580_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 2h_LT2_exposed

```{r 2h_LT2_exposed}
DT::datatable(
  DE.res.batch[["2h_LT2_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 2h_LT2_infected

```{r 2h_LT2_infected}
DT::datatable(
  DE.res.batch[["2h_LT2_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 4h_D23580_exposed

```{r 4h_D23580_exposed}
DT::datatable(
  DE.res.batch[["4h_D23580_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 4h_D23580_infected

```{r 4h_D23580_infected}
DT::datatable(
  DE.res.batch[["4h_D23580_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 4h_LT2_exposed

```{r 4h_LT2_exposed}
DT::datatable(
  DE.res.batch[["4h_LT2_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 4h_LT2_infected

```{r 4h_LT2_infected}
DT::datatable(
  DE.res.batch[["4h_LT2_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 6h_D23580_exposed

```{r 6h_D23580_exposed}
DT::datatable(
  DE.res.batch[["6h_D23580_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 6h_D23580_infected

```{r 6h_D23580_infected}
DT::datatable(
  DE.res.batch[["6h_D23580_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 6h_LT2_exposed

```{r 6h_LT2_exposed}
DT::datatable(
  DE.res.batch[["6h_LT2_exposed"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

## 6h_LT2_infected

```{r 6h_LT2_infected}
DT::datatable(
  DE.res.batch[["6h_LT2_infected"]],
  options = list(pageLength = 10, searching = TRUE), filter = "top"
)
```

<!-- As HTML pages are built independently, objects need to be saved to disk
and imported as needed by the other R mardown files -->
