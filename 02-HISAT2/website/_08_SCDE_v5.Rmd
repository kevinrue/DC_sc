---
title: "Differential expression using scde"
bibliography:
  bibtex.bib
---

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
library(scater)
library(scran)
library(scde)
library(ensembldb)
library(dplyr)
sce.norm <- readRDS("rds/sce.norm.tSNE.rds")
EnsDb.Hsapiens.v79 <- EnsDb.Hsapiens.v79::EnsDb.Hsapiens.v79
scde.res <- readRDS("rds/scde.res_v5.rds")
```

<!-- Cleaner code for v3
Remove ERCC spike-ins
Error model: {all cells; all genes}
Prior
!! Split cells by time
DE: {group - time cells w NA; batch - all cells w/out NA}
-->

# Prepare data

The analysis starts with a matrix of read counts,
filtered based on gene and cell requirements.
In this case, let us use the raw numbers of reads mapped to each endogenous
feature, recast as `integer` type:

```{r table_isSpike}
table(isSpike(sce.norm))
```

```{r cleanCounts}
cd <- counts(sce.norm)[!isSpike(sce.norm),]
storage.mode(cd) <- 'integer'
dim(cd)
```

Let us also define a factor that separate cells from each experimental group:

```{r sg}
sg <- sce.norm$Group
names(sg) <- colnames(sce.norm)  
```

# Fitting error models

Here, we fit the error models on which all subsequent calculations
will rely. The fitting process relies on a subset of robust genes that are
detected in multiple cross-cell comparisons. Here we supply the groups
defined above to the `groups` argument, so that the error models for each
experimental group of cells are fit independently
(using `r length(levels(sg))` different sets of "robust" genes in this case).
If the groups argument is omitted, the models would be fit using a common set.

**Note:** this step takes a considerable amount of time
(~ 1 h using 4 cores to fit error models to each of the
`r ncol(sce.norm)` cells).

<!--
Run blocks labelled eval=FALSE below manually,
to compute and save object to file;
The computed objects will be imported from file
to knit the HTML page,
if and only if the cache of the corresponding page is cleared.
-->

```{r oifm, eval=FALSE}
o.ifm <- scde.error.models(
  counts = cd, groups = sg,
  n.cores = 4, verbose = 1
)
```

```{r o.ifm_csv, eval=FALSE}
write.csv(o.ifm, "SCDE_v4/o.ifm.csv")
```

```{r saveRdsOifm, eval=FALSE, echo=FALSE}
saveRDS(o.ifm, "rds/o.ifm_v4.rds")
```

```{r readOIfm, include=FALSE}
o.ifm <- readRDS("rds/o.ifm_v4.rds")
```

Particularly poor cells may result in abnormal fits, most commonly showing
negative `corr.a`, and should be removed.

```{r validCells}
valid.cells <- o.ifm$corr.a > 0
table(valid.cells)
o.ifm <- o.ifm[valid.cells, ]
```

Here, all the fits were valid (most likely owing to the removal of outliers
during earlier [sample QC](03_sampleQC.html)); as a consequence,
the above chunk of code does not actually do anything to the data.

## Match sample order

The `scde.error.models` function produces a `data.frame` with samples
grouped by the experimental grouping factor supplied during the fitting.

Let us reorder the `SCESet` and the extracted count matrix to match the
same order and avoid confusion:

```{r o.ifm.order}
o.ifm.order <- match(rownames(o.ifm), sampleNames(sce.norm))
sce.ifm <- sce.norm[,o.ifm.order]
cd.ifm <- counts(sce.ifm)[!isSpike(sce.ifm),]; storage.mode(cd.ifm) <- "integer"
```

```{r o.ifm.order_stopifnot, include=FALSE}
stopifnot(rownames(o.ifm) == sampleNames(sce.ifm))
stopifnot(rownames(o.ifm) == colnames(cd.ifm))
```

# Estimate prior distribution for gene expression magnitudes

Finally, we need to define an expression magnitude prior for the genes.
Its main function, however, is to define a grid of expression magnitude values
on which the numerical calculations will be carried out.

```{r oPrior}
o.prior <- scde.expression.prior(
  models = o.ifm, counts = cd.ifm, length.out = 400, show.plot = TRUE
)
```

# Differential expression

## Setup

Let us first define:

* a list to store the result tables returned by *scde*

```{r scde.res_init, eval=FALSE}
scde.res <- list()
```

* a function used to convert the Z-score computed by *scde* to a empirical
P-value ([reference](https://www.biostars.org/p/17227/)):

```{r convert.z.score}
convert.z.score <- function(x, one.sided = NULL) {
  z <- x$Z
  if(is.null(one.sided)) {
    pval = pnorm(-abs(z));
    pval = 2 * pval
  } else if(one.sided=="-") {
    pval = pnorm(z);
  } else {
    pval = pnorm(-z);
  }
    x <- cbind(
      x,
      p.value = pval
  )
  return(x);
}   
```

* a function used to annotate the tables of results returned by *scde*:

```{r addGENENAME}
addGENENAME <- function(x){
  x <- cbind(
    GENENAME=mapIds(EnsDb.Hsapiens.v79, rownames(x), 'GENENAME', 'GENEID'),
    x
  )
  return(x)
}
```

* a function to order results by decreasing absolute
corrected Z-score and subsequently absolute Z-score:

```{r orderResults}
orderResults <- function(x){
  x <- x[with(x, order(abs(cZ), abs(Z), decreasing = TRUE)),]
  return(x)
}
```

* a function to visualise *scran*-normalised gene expression for a given
gene:

Let us also define a function that displays normalised (*scran*) expression
data in each group:

```{r normExprsByName}
normExprsById <- function(geneId){
  geneName <- subset(fData(sce.norm), gene_id == geneId, "gene_name", drop = TRUE)
  gdata <- data.frame(
    norm_exprs = norm_exprs(sce.norm)[geneId,],
    pData(sce.norm)[,c("Infection","Status","Time")],
    row.names = sampleNames(sce.norm)
  )
  ggplot(gdata, aes(Infection, norm_exprs)) + 
    geom_violin() + geom_jitter(width = 0.1) +
    facet_grid(Time ~ Status) +
    ggtitle(sprintf("%s - %s", geneId, geneName))
}
```

* a function to visualise *scde* estimate of expression and differential
  expression for a given gene (identifier) in a given contrast:
  
  
```{r}
single.scde <- function(gene, groupTarget, groupRef){
  sg.test <- factor(sce.ifm$Group,levels = c(groupTarget, groupRef))
  scde.test.gene.expression.difference(
    gene = gene,
    o.ifm, cd.ifm, o.prior, groups = sg.test, batch = sce.ifm$Plate,
    n.cores = 4, verbose = 1
  )
}
```

* various significance levels:

```{r volcano.sig}
sig.levels <- c(0.05, 0.01)
volcano.sig <- data.frame(
  P = sig.levels,
  level = as.character(sig.levels)
)
```

* a function to visualise *scde* differential expression statistics, and
  return a table with those statistics augmented by a an empirical *P* value
  computed from the *Z* score returned by *scde*:

```{r volcano.mle}
volcano.mle <- function(
  contrastName, tableName = c("results","batch.adjusted","batch.effect")){
  tableName <- match.arg(tableName)
  scde.adj <- scde.res[[contrastName]][[tableName]]
  scde.adj <- convert.z.score(addGENENAME(orderResults(scde.adj)))
  gg <- ggplot(scde.adj, aes(mle, -log10(p.value))) +
    geom_point(aes(colour = (cZ != 0))) +
    geom_hline(aes(yintercept = -log10(P), linetype = level), volcano.sig) +
    ggtitle(gsub("_", " ", contrastName), tableName)
  print(gg)
  return(scde.adj)
}
```

## Contrasts {.tabset}

### List

```{r contrastList}
contrasts.2h <- list(
  c("2h_D23580_infected", "2h_Mock_uninfected"), # vs. Mock
  c("2h_LT2_infected", "2h_Mock_uninfected"),
  c("2h_D23580_exposed", "2h_Mock_uninfected"),
  c("2h_LT2_exposed", "2h_Mock_uninfected"),
  c("2h_D23580_infected", "2h_LT2_infected"), # direct
  c("2h_D23580_infected", "2h_D23580_exposed"),
  c("2h_LT2_infected", "2h_LT2_exposed"),
  c("2h_D23580_exposed", "2h_LT2_exposed")
)
contrasts.4h <- list(
  c("4h_D23580_infected", "4h_Mock_uninfected"), # 4h
  c("4h_LT2_infected", "4h_Mock_uninfected"),
  c("4h_D23580_exposed", "4h_Mock_uninfected"),
  c("4h_LT2_exposed", "4h_Mock_uninfected"),
  c("4h_D23580_infected", "4h_LT2_infected"), # 4h
  c("4h_D23580_infected", "4h_D23580_exposed"),
  c("4h_LT2_infected", "4h_LT2_exposed"),
  c("4h_D23580_exposed", "4h_LT2_exposed")
)
contrasts.6h <- list(
  c("6h_D23580_infected", "6h_Mock_uninfected"), # 6h
  c("6h_LT2_infected", "6h_Mock_uninfected"),
  c("6h_D23580_exposed", "6h_Mock_uninfected"),
  c("6h_LT2_exposed", "6h_Mock_uninfected"),
  c("6h_D23580_infected", "6h_LT2_infected"), # 6h
  c("6h_D23580_infected", "6h_D23580_exposed"),
  c("6h_LT2_infected", "6h_LT2_exposed"),
  c("6h_D23580_exposed", "6h_LT2_exposed")
)
```

### 2h

```{r}
sce.2h <- sce.ifm[,sce.ifm$Time == '2h']
cd.2h <- cd.ifm[,sampleNames(sce.2h)]
o.ifm.2h <- o.ifm[sampleNames(sce.2h),]
```

```{r, eval=FALSE}
for (contrastNames in contrasts.2h[4:8]){
  groupTarget <- contrastNames[1]; groupRef <- contrastNames[2]
  sg.test <- factor(sce.2h$Group, levels = c(groupTarget, groupRef))
  names(sg.test) <- sampleNames(sce.2h); print(summary(sg.test))
  batch.test <- sce.2h$Plate; print(summary(batch.test))
  contrastName <- sprintf("%s-%s", groupTarget, groupRef); message(contrastName)
  scde.res[[contrastName]] <- scde.expression.difference(
    o.ifm.2h, cd.2h, o.prior, groups = sg.test, batch = batch.test,
    n.cores = 4, verbose = 1
  )
  saveRDS(scde.res, "rds/scde.res_v5.rds")
}
```

### 4h

```{r}
sce.4h <- sce.ifm[,sce.ifm$Time == '4h']
cd.4h <- counts(sce.4h); storage.mode(cd.4h) <- "integer"
o.ifm.4h <- o.ifm[sampleNames(sce.4h),]
```

```{r, eval=TRUE}
for (contrastNames in contrasts.4h){
  groupTarget <- contrastNames[1]; groupRef <- contrastNames[2]
  sg.test <- factor(sce.4h$Group, levels = c(groupTarget, groupRef))
  names(sg.test) <- sampleNames(sce.4h); print(summary(sg.test))
  batch.test <- sce.4h$Plate; print(summary(batch.test))
  contrastName <- sprintf("%s-%s", groupTarget, groupRef); message(contrastName)
  scde.res[[contrastName]] <- scde.expression.difference(
    o.ifm.4h, cd.4h, o.prior, groups = sg.test, batch = batch.test,
    n.cores = 4, verbose = 1
  )
  saveRDS(scde.res, "rds/scde.res_v5.rds")
}
```

### 6h

```{r}
sce.6h <- sce.ifm[,sce.ifm$Time == '6h']
cd.6h <- counts(sce.6h); storage.mode(cd.6h) <- "integer"
o.ifm.6h <- o.ifm[sampleNames(sce.6h),]
```

```{r, eval=TRUE}
for (contrastNames in contrasts.6h){
  groupTarget <- contrastNames[1]; groupRef <- contrastNames[2]
  sg.test <- factor(sce.6h$Group, levels = c(groupTarget, groupRef))
  names(sg.test) <- sampleNames(sce.6h); print(summary(sg.test))
  batch.test <- sce.6h$Plate; print(summary(batch.test))
  contrastName <- sprintf("%s-%s", groupTarget, groupRef); message(contrastName)
  scde.res[[contrastName]] <- scde.expression.difference(
    o.ifm.6h, cd.6h, o.prior, groups = sg.test, batch = batch.test,
    n.cores = 4, verbose = 1
  )
  saveRDS(scde.res, "rds/scde.res_v5.rds")
}
```

<!-- Run manually -->

```{r, eval=FALSE, echo=FALSE}
for (contrastName in names(scde.res)){
  scde.raw <- scde.res[[contrastName]]$results
  scde.raw <- convert.z.score(addGENENAME(orderResults(scde.raw)))
  csv.raw <- sprintf("SCDE_v5/raw.%s.csv", contrastName)
  write.csv(scde.raw, csv.raw)
}
for (contrastName in names(scde.res)){
  scde.adjusted <- scde.res[[contrastName]]$batch.adjusted
  scde.adjusted <- convert.z.score(addGENENAME(orderResults(scde.adjusted)))
  csv.raw <- sprintf("SCDE_v5/adjusted.%s.csv", contrastName)
  write.csv(scde.adjusted, csv.raw)
}
for (contrastName in names(scde.res)){
  scde.batch <- scde.res[[contrastName]]$batch.effect
  scde.batch <- convert.z.score(addGENENAME(orderResults(scde.batch)))
  csv.raw <- sprintf("SCDE_v5/batch.%s.csv", contrastName)
  write.csv(scde.batch, csv.raw)
}
```

# Examine one contrast {.tabset}

## 2h

```{r}
tmp.table <- volcano.mle(names(scde.res)[1], "results")
tmp.table <- volcano.mle(names(scde.res)[1], "batch.adjusted")
```

Order and filter genes that pass a significance cut-off:

```{r}
tmp.table <- tmp.table[rev(order(abs(tmp.table$Z))),]
tmp.sig <- subset(tmp.table, p.value < 0.01)
dim(tmp.sig)
```

Last gene that passed the above significance cut-off,
in the *scran* normalised data set:

```{r}
normExprsById(tail(rownames(tmp.sig), 1))
```

Similarly, in the *scde* model:

```{r}
single.scde(tail(rownames(tmp.sig), 1),"2h_D23580_infected","2h_Mock_uninfected")
```

```{r}
single.scde("ENSG00000170345","2h_D23580_infected","2h_Mock_uninfected") # FOS
```

## 6h

```{r}
tmp.table <- volcano.mle(names(scde.res)[9], "results")
tmp.table <- volcano.mle(names(scde.res)[9], "batch.adjusted")
```

Order and filter genes that pass a significance cut-off:

```{r}
tmp.table <- tmp.table[rev(order(abs(tmp.table$Z))),]
tmp.sig <- subset(tmp.table, p.value < 0.01)
dim(tmp.sig)
```

Last gene that passed the above significance cut-off,
in the *scran* normalised data set:

```{r}
normExprsById(tail(rownames(tmp.sig), 1))
```

Similarly, in the *scde* model:

```{r}
single.scde(tail(rownames(tmp.sig), 1),"6h_D23580_infected","6h_Mock_uninfected")
```

```{r}
single.scde("ENSG00000170345","6h_D23580_infected","6h_Mock_uninfected") # FOS
```
