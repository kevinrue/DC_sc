---
title: "Markers of clusters using *scde*"
bibliography:
  bibtex.bib
---

<!-- As HTML pages are built independently, large objects need to be
reimported from disk, and smaller ones quickly recomputed. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
stopifnot(
  require(scater),
  require(scran),
  require(ggplot2),
  require(ComplexHeatmap),
  require(dplyr),
  require(ggrepel),
  require(RColorBrewer),
  require(goseq),
  require(scde),
  requireNamespace("circlize")
)
sce.endo <- readRDS("rds/sce.endo_clusters.rds")
o.ifm.2h <- readRDS("rds/o.ifm_2h.rds")
o.ifm.4h <- readRDS("rds/o.ifm_4h.rds")
o.ifm.6h <- readRDS("rds/o.ifm_6h.rds")
col.time <- brewer.pal(9, "Set3")[c(2,7:8)]
col.infection <- brewer.pal(12, "Paired")[c(9,4,2)]
col.status <- brewer.pal(12, "Paired")[c(9,1,7)]
names(col.time) <- levels(sce.endo$Time)[1:3]
names(col.infection) <- levels(sce.endo$Infection)
names(col.status) <- levels(sce.endo$Status)
outdir <- "06_markers_out"; dir.create(outdir, showWarnings = FALSE)
scde.res <- readRDS("rds/cluster_scde_res.rds")
# Subset by time point
sce.2h <- sce.endo[,sce.endo$Time == '2h']
sce.4h <- sce.endo[,sce.endo$Time == '4h']
sce.6h <- sce.endo[,sce.endo$Time == '6h']
# Filter detected genes
filterCounts <- function(m, counts = 10, cells = 10){
  apply(m, 1, function(e){
    return(sum(e >= counts) >= cells)
  })
}
sg.2h <- droplevels(sce.2h$Group)
keep.2h <- filterCounts(counts(sce.2h))
cd.2h <- counts(sce.2h)[keep.2h,]; storage.mode(cd.2h) <- 'integer'
sg.4h <- droplevels(sce.4h$Group)
keep.4h <- filterCounts(counts(sce.4h))
cd.4h <- counts(sce.4h)[keep.4h,]; storage.mode(cd.4h) <- 'integer'
sg.6h <- droplevels(sce.6h$Group)
keep.6h <- filterCounts(counts(sce.6h))
cd.6h <- counts(sce.6h)[keep.6h,]; storage.mode(cd.6h) <- 'integer'
# Reorder SCESet to match count matrix
sce.ifm.2h <- sce.2h[,rownames(o.ifm.2h)]
cd.ifm.2h <- counts(sce.ifm.2h); storage.mode(cd.ifm.2h) <- "integer"
sce.ifm.4h <- sce.4h[,rownames(o.ifm.4h)]
cd.ifm.4h <- counts(sce.ifm.4h); storage.mode(cd.ifm.4h) <- "integer"
sce.ifm.6h <- sce.6h[,rownames(o.ifm.6h)]
cd.ifm.6h <- counts(sce.ifm.6h); storage.mode(cd.ifm.6h) <- "integer"
# Prior of expression
o.prior.2h <- scde.expression.prior(
  models = o.ifm.2h, counts = cd.ifm.2h, show.plot = FALSE
)
o.prior.4h <- scde.expression.prior(
  models = o.ifm.4h, counts = cd.ifm.4h, show.plot = FALSE
)
o.prior.6h <- scde.expression.prior(
  models = o.ifm.6h, counts = cd.ifm.6h, show.plot = FALSE
)
# Functions
convert.z.score <- function(x, one.sided = NULL) {
  z <- x$Z
  if(is.null(one.sided)) {
    pval = pnorm(-abs(z));
    pval = 2 * pval
  } else if(one.sided=="-") {
    pval = pnorm(z);
  } else {
    pval = pnorm(-z);
  }
    x <- cbind(
      x,
      p.value = pval
  )
  return(x);
}   
addGENENAME <- function(x){
  x <- cbind(
    GENENAME = with(rowData(sce.endo), gene_name[match(rownames(x), gene_id)]),
    x
  )
  return(x)
}
orderResults <- function(x){
  x <- x[with(x, order(abs(Z), decreasing = TRUE)),]
  return(x)
}
sig.levels <- c(0.05, 0.01)
volcano.sig <- data.frame(
  P = sig.levels,
  level = as.character(sig.levels)
)
volcano.mle <- function(x, sub = NULL){
  varName <- deparse(substitute(x))
  x <- convert.z.score(x)
  gg <- ggplot(x, aes(mle, -log10(p.value))) +
    geom_point(aes(colour = (cZ != 0))) +
    geom_hline(aes(yintercept=-log10(p.value),linetype=level),volcano.sig) +
    ggtitle(varName, sub)
  print(gg)
  return(x)
}
```

<!-- Cleaner code based on 05_SCDE
Remove ERCC spike-ins
!! Split cells by time
!! Retain genes detected at each time (10 counts, 5 cells, 1 group)
Identify cell clusters @ time
<!-- Error model: {cells @ time; genes @ time}
Prior @ time
DE: {group on all cells with NA; no batch correction; P-value < 0.01}
-->

# Preprocessed data

**Note:**
for this analysis, the data is prepared identically to the
[differential expression between experimental groups using *scde*](05_SCDE.html):

* ERCC spike-in features are removed,
* Cells in the data set is subsetted by time point,
* Genes in the data set are subsetted for those detected at sufficient levels
  within each time point,
* Error models are computed on the subsetted data sets

# Differential expression {#DE}

## Setup

Let us first define a list to store the result tables returned by *scde*:

```{r scde.res_init, eval=FALSE}
scde.res <- list()
```

In addition, note that several functions defined in the first
[scde section](08_SCDE_v8.html#DE) will be re-used here.

### 2h

```{r scde.res_2h, eval=FALSE}
for (clusterId in levels(sce.ifm.2h$quickCluster.2h)){
  sg.test <- factor(
    sce.ifm.2h$quickCluster.2h == clusterId,
    levels = c(TRUE, FALSE),
    labels = c(clusterId, "Others"))
  names(sg.test) <- colnames(sce.ifm.2h); summary(sg.test)
  contrastName <- sprintf("2h_cluster%s-Others", clusterId);message(contrastName)
  scde.res[[contrastName]] <- scde.expression.difference(
      o.ifm.2h, cd.2h, o.prior.2h, sg.test, n.cores = 4, verbose = 1
    )
}
```

### 4h

```{r scde.res_4h, eval=FALSE}
for (clusterId in levels(sce.ifm.4h$quickCluster.4h)){
  sg.test <- factor(
    sce.ifm.4h$quickCluster.4h == clusterId,
    levels = c(TRUE, FALSE),
    labels = c(clusterId, "Others"))
  names(sg.test) <- colnames(sce.ifm.4h); summary(sg.test)
  contrastName <- sprintf("4h_cluster%s-Others", clusterId);message(contrastName)
  scde.res[[contrastName]] <- scde.expression.difference(
      o.ifm.4h, cd.4h, o.prior.4h, sg.test, n.cores = 4, verbose = 1
    )
}
```

### 6h

```{r scde.res_6h, eval=FALSE}
for (clusterId in levels(sce.ifm.6h$quickCluster.6h)){
  sg.test <- factor(
    sce.ifm.6h$quickCluster.6h == clusterId,
    levels = c(TRUE, FALSE),
    labels = c(clusterId, "Others"))
  names(sg.test) <- colnames(sce.ifm.6h); summary(sg.test)
  contrastName <- sprintf("6h_cluster%s-Others", clusterId);message(contrastName)
  scde.res[[contrastName]] <- scde.expression.difference(
      o.ifm.6h, cd.6h, o.prior.6h, sg.test, n.cores = 4, verbose = 1
    )
}
```

```{r scde.table_csv, echo=FALSE, eval=FALSE}
saveRDS(scde.res, "rds/cluster_scde_res.rds")
for (contrastName in names(scde.res)){
  scde.table <- scde.res[[contrastName]]
  scde.table <- convert.z.score(addGENENAME(orderResults(scde.table)))
  csv.file <- sprintf("SCDE_cluster_%s.csv", contrastName)
  write.csv(scde.table, file.path(outdir, csv.file))
}
```

# Heat map of fold-change for (up to) 50 markers {.tabset}

For each time point, let us display up to 50 marker genes for each cluster, selected for having:

* *P*-value less than 0.01
* *mle* of log fold-change among the 50 largest positive values for a cluster

First of all, let us define a color scale share between upcoming heat maps:

```{r ht.col}
ht.col <- c("purple", "black", "yellow")
```

## 2h

```{r markers_FC_2h, echo=FALSE, fig.height=10, message=FALSE}
markers_2h <- character()
markers_2h.cluster <- factor(NULL, levels(sce.ifm.2h$quickCluster.2h))
c2h <- grep("^2h", names(scde.res), value = TRUE)
for (contrastName in c2h){
  clusterId <- gsub("2h_cluster(.)-Others", "\\1", contrastName)
  scde.table <- addGENENAME(convert.z.score(scde.res[[contrastName]]))
  scde.table <- subset(scde.table, mle > 0 & p.value < 0.01)
  scde.table <- scde.table[order(scde.table$mle, decreasing = TRUE),]
  scde.markers <- head(rownames(scde.table), 50)
  markers_2h <- c(markers_2h, scde.markers)
  markers_2h.cluster <-
    c(markers_2h.cluster, rep(clusterId, length(scde.markers)))
}
markersMatrix <- matrix(
  nrow = length(markers_2h),
  ncol = length(c2h),
  dimnames = list(
    gene_id = markers_2h,
    cluster = gsub("2h_cluster(.)-Others", "\\1", c2h)
  ))
for (contrastName in c2h){
  scde.table <- addGENENAME(convert.z.score(scde.res[[contrastName]]))
  clusterName <- gsub("2h_cluster(.)-Others", "\\1", contrastName)
  markersMatrix[,clusterName] <- scde.table[rownames(markersMatrix),"mle"]
}
rownames(markersMatrix) <-
  with(rowData(sce.2h), gene_name[match(rownames(markersMatrix), gene_id)])
ht <- Heatmap(
  matrix = markersMatrix,
  cluster_rows = FALSE, cluster_columns = FALSE,
  row_names_gp = gpar(cex=0.4)
  )
draw(ht)
```

```{r markers_FC_2h_pdf, include=FALSE}
pdf(file.path(outdir, "2h_markers_heatmap.pdf"), width = 8, height = 15)
draw(ht)
dev.off()
```

## 4h

```{r markers_FC_4h, echo=FALSE, fig.height=10}
markers_4h <- character()
markers_4h.cluster <- factor(NULL, levels(sce.ifm.4h$quickCluster.4h))
c4h <- grep("^4h", names(scde.res), value = TRUE)
for (contrastName in c4h){
  clusterId <- gsub("4h_cluster(.)-Others", "\\1", contrastName)
  scde.table <- addGENENAME(convert.z.score(scde.res[[contrastName]]))
  scde.table <- subset(scde.table, mle > 0 & p.value < 0.01)
  scde.table <- scde.table[order(scde.table$mle, decreasing = TRUE),]
  scde.markers <- head(rownames(scde.table), 50)
  markers_4h <- c(markers_4h, scde.markers)
  markers_4h.cluster <-
    c(markers_4h.cluster, rep(clusterId, length(scde.markers)))
}
markersMatrix <- matrix(
  nrow = length(markers_4h),
  ncol = length(c4h),
  dimnames = list(
    gene_id = markers_4h,
    cluster = gsub("4h_cluster(.)-Others", "\\1", c4h)
  ))
for (contrastName in c4h){
  scde.table <- addGENENAME(convert.z.score(scde.res[[contrastName]]))
  clusterName <- gsub("4h_cluster(.)-Others", "\\1", contrastName)
  markersMatrix[,clusterName] <- scde.table[rownames(markersMatrix),"mle"]
}
rownames(markersMatrix) <-
  with(rowData(sce.4h), gene_name[match(rownames(markersMatrix), gene_id)])
ht <- Heatmap(
  matrix = markersMatrix,
  cluster_rows = FALSE, cluster_columns = FALSE,
  row_names_gp = gpar(cex=0.4)
  )
draw(ht)
```

```{r markers_FC_4h_pdf, include=FALSE}
pdf(file.path(outdir, "4h_markers_heatmap.pdf"), width = 8, height = 15)
draw(ht)
dev.off()
```

## 6h

```{r markers_FC_6h, echo=FALSE, fig.height=10}
markers_6h <- character()
markers_6h.cluster <- factor(NULL, levels(sce.ifm.6h$quickCluster.6h))
c6h <- grep("^6h", names(scde.res), value = TRUE)
for (contrastName in c6h){
  clusterId <- gsub("6h_cluster(.)-Others", "\\1", contrastName)
  scde.table <- addGENENAME(convert.z.score(scde.res[[contrastName]]))
  scde.table <- subset(scde.table, mle > 0 & p.value < 0.01)
  scde.table <- scde.table[order(scde.table$mle, decreasing = TRUE),]
  scde.markers <- head(rownames(scde.table), 50)
  markers_6h <- c(markers_6h, scde.markers)
  markers_6h.cluster <-
    c(markers_6h.cluster, rep(clusterId, length(scde.markers)))
}
markersMatrix <- matrix(
  nrow = length(markers_6h),
  ncol = length(c6h),
  dimnames = list(
    gene_id = markers_6h,
    cluster = gsub("6h_cluster(.)-Others", "\\1", c6h)
  ))
for (contrastName in c6h){
  scde.table <- addGENENAME(convert.z.score(scde.res[[contrastName]]))
  clusterName <- gsub("6h_cluster(.)-Others", "\\1", contrastName)
  markersMatrix[,clusterName] <- scde.table[rownames(markersMatrix),"mle"]
}
rownames(markersMatrix) <-
  with(rowData(sce.6h), gene_name[match(rownames(markersMatrix), gene_id)])
ht <- Heatmap(
  matrix = markersMatrix,
  cluster_rows = FALSE, cluster_columns = FALSE,
  row_names_gp = gpar(cex=0.4)
  )
draw(ht)
```

```{r markers_FC_6h_pdf, include=FALSE}
pdf(file.path(outdir, "6h_markers_heatmap.pdf"), width = 8, height = 15)
draw(ht)
dev.off()
```

# Heat map of log-counts for (up to) 50 markers {.tabset}

Notably, let us use here the same markers as defined in the previous section,
namely:

* *P*-value less than 0.01
* *mle* of log fold-change among the 50 largest positive values for a cluster

## 2h

```{r markers_logcounts_2h, echo=FALSE, fig.height=10, message=FALSE}
ht_list <- list()
markersMatrix <- assay(sce.ifm.2h, "logcounts")[markers_2h,]
markersMatrix <- t(scale(t(markersMatrix)))
rownames(markersMatrix) <- with(
    rowData(sce.2h), gene_name[match(rownames(markersMatrix), gene_id)])
# maxMatrix <- max(abs(range(markersMatrix))) * ht.scale.percentile
ht_scale <- circlize::colorRamp2(c(-4, 0, 4), ht.col) # use maxMatrix?
for (clusterId in levels(sce.ifm.2h$quickCluster.2h)){
  clusterMatrix <- markersMatrix[,sce.ifm.2h$quickCluster.2h == clusterId]
  ht_list[[clusterId]] <- Heatmap(
    matrix = clusterMatrix,
    name = ifelse(
      clusterId == levels(sce.ifm.2h$quickCluster.2h)[1],
      "z-score",
      clusterId),
    col = ht_scale,
    row_names_gp = gpar(cex=0.4),
    show_heatmap_legend =
      clusterId == levels(sce.ifm.2h$quickCluster.2h)[1],
    show_row_names = clusterId == levels(sce.ifm.2h$quickCluster.2h)[1],
    cluster_rows = FALSE,
    show_column_names = FALSE, show_column_dend = FALSE,
    row_names_side = "left",
    split = markers_2h.cluster
    )
}
ht_final <- ht_list[["0"]] + ht_list[["1"]] + ht_list[["2"]] + ht_list[["3"]]
draw(ht_final)
```

```{r markers_logcounts_2h_pdf, include=FALSE}
pdf(
  file.path(outdir, "2h_markers_heatmap_logcounts.pdf"),
  width = 10, height = 15)
draw(ht_final)
dev.off()
```

## 2h (w/out '0')

```{r markers_logcounts_2h_no0, echo=FALSE, fig.height=10, message=FALSE}
ht_list <- list()
excludeMarkers <- which(markers_2h.cluster == "0")
markers_2h_no0 <- markers_2h[-excludeMarkers]
markers_2h.cluster_no0 <- markers_2h.cluster[-excludeMarkers]
markersMatrix <- assay(sce.ifm.2h, "logcounts")[markers_2h_no0,]
markersMatrix <- t(scale(t(markersMatrix)))
rownames(markersMatrix) <- with(
    rowData(sce.2h), gene_name[match(rownames(markersMatrix), gene_id)])
# maxMatrix <- max(abs(range(markersMatrix))) * ht.scale.percentile
ht_scale <- circlize::colorRamp2(c(-4, 0, 4), ht.col) # use maxMatrix?
for (clusterId in unique(markers_2h.cluster_no0)){
  clusterMatrix <- markersMatrix[,sce.ifm.2h$quickCluster.2h == clusterId]
  ht_list[[clusterId]] <- Heatmap(
    matrix = clusterMatrix,
    name = ifelse(clusterId == "1", "z-score", clusterId),
    col = ht_scale,
    row_names_gp = gpar(cex=0.4),
    show_heatmap_legend = clusterId == "1",
    show_row_names = clusterId == "1",
    cluster_rows = FALSE,
    show_column_names = FALSE, show_column_dend = FALSE,
    row_names_side = "left",
    split = markers_2h.cluster_no0
    )
}
ht_final <- ht_list[["1"]] + ht_list[["2"]] + ht_list[["3"]]
draw(ht_final)
```

```{r markers_logcounts_2h_no0_pdf, include=FALSE}
pdf(
  file.path(outdir, "2h_markers_heatmap_logcounts_no0.pdf"),
  width = 10, height = 15)
draw(ht_final)
dev.off()
```

```{r markers_logcounts_2h_no0_annolink, include=FALSE}
ht_list <- list()
excludeMarkers <- which(markers_2h.cluster == "0")
markers_2h_no0 <- markers_2h[-excludeMarkers]
markers_2h.cluster_no0 <- markers_2h.cluster[-excludeMarkers]
markersMatrix <- assay(sce.ifm.2h, "logcounts")[markers_2h_no0,]
markersMatrix <- t(scale(t(markersMatrix)))
rownames(markersMatrix) <- with(
    rowData(sce.2h), gene_name[match(rownames(markersMatrix), gene_id)])
# maxMatrix <- max(abs(range(markersMatrix))) * ht.scale.percentile
ht_scale <- circlize::colorRamp2(c(-4, 0, 4), ht.col) # use maxMatrix?
for (clusterId in unique(markers_2h.cluster_no0)){
  clusterMatrix <- markersMatrix[,sce.ifm.2h$quickCluster.2h == clusterId]
  ht_list[[clusterId]] <- Heatmap(
    matrix = clusterMatrix,
    name = ifelse(clusterId == "1", "z-score", clusterId),
    col = ht_scale,
    row_names_gp = gpar(cex=0.4),
    show_heatmap_legend = clusterId == "1",
    show_row_names = clusterId == "1",
    cluster_rows = FALSE,
    show_column_names = FALSE, show_column_dend = FALSE,
    row_names_side = "left",
    split = markers_2h.cluster_no0
    )
}
geneNames <- c(
  "CCL24","CYBB","CCL7","CMKLR1","ME1","MMP19","MAFB","SERPINB2","IL10","GSDMA",
  "DDX60L","TMEM158","CD163","FAM83G","RNASE1","FAM107B","IRAK3","KLHL21",
  "CHST13","CTSL","CXCL2","FOXO3","SPSB1","MAPK13","LAMP1","MS4A4A","CHST15",
  "MMP9","AGPAT4","CCL26","LGMN","SERPINE1","CD1A","TNF","GOLGA8B","ADAM19",
  "GOLGA8A","CD40","CD1C","CLEC10A","TUBA1A","IER3","CLEC4A","SLC25A6","SOCS1",
  "CD1A","LIPA","SLC25A5","CD1C","CACYBP","TUBA1A","ALOX15","ATP5G3","ARHGDIB"
)
ht_final <- ht_list[["1"]] + ht_list[["2"]] + ht_list[["3"]] + rowAnnotation(
  link = row_anno_link(
    at = which(rownames(markersMatrix) %in% geneNames),
    labels = geneNames,
    labels_gp = gpar(cex=2/3),
    link_width = unit(0.5, "inches")
  ),
  width = unit(1, "cm") + max_text_width(labels)
)
pdf(
  file.path(outdir, "2h_markers_heatmap_logcounts_no0_rowLink.pdf"),
  width = 10, height = 10)
draw(ht_final)
dev.off()
```

## 4h

```{r markers_logcounts_4h, echo=FALSE, fig.height=10, message=FALSE}
ht_list <- list()
markersMatrix <- assay(sce.ifm.4h, "logcounts")[markers_4h,]
markersMatrix <- t(scale(t(markersMatrix)))
rownames(markersMatrix) <- with(
    rowData(sce.4h), gene_name[match(rownames(markersMatrix), gene_id)])
# maxMatrix <- max(abs(range(markersMatrix))) * ht.scale.percentile
ht_scale <- circlize::colorRamp2(c(-4, 0, 4), ht.col) # use maxMatrix?
for (clusterId in levels(sce.ifm.4h$quickCluster.4h)){
  clusterMatrix <- markersMatrix[,sce.ifm.4h$quickCluster.4h == clusterId]
  ht_list[[clusterId]] <- Heatmap(
    matrix = clusterMatrix,
    name = ifelse(
      clusterId == levels(sce.ifm.4h$quickCluster.4h)[1],
      "z-score",
      clusterId),
    col = ht_scale,
    row_names_gp = gpar(cex=0.4),
    show_heatmap_legend =
      clusterId == levels(sce.ifm.4h$quickCluster.4h)[1],
    show_row_names = clusterId == levels(sce.ifm.4h$quickCluster.4h)[1],
    cluster_rows = FALSE,
    show_column_names = FALSE, show_column_dend = FALSE,
    row_names_side = "left",
    split = markers_4h.cluster
    )
}
ht_final <- ht_list[["0"]] + ht_list[["1"]] + ht_list[["2"]] + ht_list[["3"]]
draw(ht_final)
```

```{r markers_logcounts_4h_pdf, include=FALSE}
pdf(
  file.path(outdir, "4h_markers_heatmap_logcounts.pdf"),
  width = 10, height = 15)
draw(ht_final)
dev.off()
```

## 6h

```{r markers_logcounts_6h, echo=FALSE, fig.height=10, message=FALSE}
ht_list <- list()
markersMatrix <- assay(sce.ifm.6h, "logcounts")[markers_6h,]
markersMatrix <- t(scale(t(markersMatrix)))
rownames(markersMatrix) <- with(
    rowData(sce.6h), gene_name[match(rownames(markersMatrix), gene_id)])
# maxMatrix <- max(abs(range(markersMatrix))) * ht.scale.percentile
ht_scale <- circlize::colorRamp2(c(-4, 0, 4), ht.col) # use maxMatrix?
for (clusterId in levels(sce.ifm.6h$quickCluster.6h)){
  clusterMatrix <- markersMatrix[,sce.ifm.6h$quickCluster.6h == clusterId]
  ht_list[[clusterId]] <- Heatmap(
    matrix = clusterMatrix,
    name = ifelse(
      clusterId == levels(sce.ifm.6h$quickCluster.6h)[1],
      "z-score",
      clusterId),
    col = ht_scale,
    row_names_gp = gpar(cex=0.4),
    show_heatmap_legend =
      clusterId == levels(sce.ifm.6h$quickCluster.6h)[1],
    show_row_names = clusterId == levels(sce.ifm.6h$quickCluster.6h)[1],
    cluster_rows = FALSE,
    show_column_names = FALSE, show_column_dend = FALSE,
    row_names_side = "left",
    split = markers_6h.cluster
    )
}
ht_final <- ht_list[["0"]] + ht_list[["1"]] + ht_list[["2"]] + ht_list[["3"]]
draw(ht_final)
```

```{r markers_logcounts_6h_pdf, include=FALSE}
pdf(
  file.path(outdir, "6h_markers_heatmap_logcounts.pdf"),
  width = 10, height = 15)
draw(ht_final)
dev.off()
```
